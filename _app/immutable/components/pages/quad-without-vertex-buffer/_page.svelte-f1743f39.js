import{S as Za,i as el,s as tl,w as J,a as y,x as M,c as w,y as K,b as v,f as X,t as Y,z as Z,h as t,k as s,q as r,l as n,m as o,r as a,G as e,p as m}from"../../../chunks/index-cc72a6df.js";import{B as dr}from"../../../chunks/BlankLink-67e3b987.js";import{M as rl,S as la,T as al}from"../../../chunks/Main-b5bd4390.js";import{S as Ya}from"../../../chunks/Subtitle-8c0c7f17.js";import{S as ll}from"../../../chunks/Seo-89a4dbfb.js";function sl(S){let f;return{c(){f=r("Quad without vertex buffer")},l(p){f=a(p,"Quad without vertex buffer")},m(p,i){v(p,f,i)},d(p){p&&t(f)}}}function nl(S){let f;return{c(){f=r("repo")},l(p){f=a(p,"repo")},m(p,i){v(p,f,i)},d(p){p&&t(f)}}}function ol(S){let f,p,i,P,u,A,c,h,R,x;return f=new al({props:{timestamp:1668709650,$$slots:{default:[sl]},$$scope:{ctx:S}}}),u=new dr({props:{href:"https://github.com/cmuratori/refterm/blob/main/refterm.hlsl#L93",$$slots:{default:[nl]},$$scope:{ctx:S}}}),{c(){J(f.$$.fragment),p=y(),i=s("p"),P=r("While I was looking through some code on GitHub, I found a "),J(u.$$.fragment),A=r(", that draws quads without having to populate a vertex buffer with data."),c=y(),h=s("p"),R=r(`The repo uses D3D11 and HLSL, so there are some small differences with the
      WebGL version of this post, but the core concept is the same.`)},l($){M(f.$$.fragment,$),p=w($),i=n($,"P",{});var E=o(i);P=a(E,"While I was looking through some code on GitHub, I found a "),M(u.$$.fragment,E),A=a(E,", that draws quads without having to populate a vertex buffer with data."),E.forEach(t),c=w($),h=n($,"P",{});var k=o(h);R=a(k,`The repo uses D3D11 and HLSL, so there are some small differences with the
      WebGL version of this post, but the core concept is the same.`),k.forEach(t)},m($,E){K(f,$,E),v($,p,E),v($,i,E),e(i,P),K(u,i,null),e(i,A),v($,c,E),v($,h,E),e(h,R),x=!0},p($,E){const k={};E&1&&(k.$$scope={dirty:E,ctx:$}),f.$set(k);const O={};E&1&&(O.$$scope={dirty:E,ctx:$}),u.$set(O)},i($){x||(X(f.$$.fragment,$),X(u.$$.fragment,$),x=!0)},o($){Y(f.$$.fragment,$),Y(u.$$.fragment,$),x=!1},d($){Z(f,$),$&&t(p),$&&t(i),Z(u),$&&t(c),$&&t(h)}}}function fl(S){let f;return{c(){f=r("Arbitrary Sized")},l(p){f=a(p,"Arbitrary Sized")},m(p,i){v(p,f,i)},d(p){p&&t(f)}}}function pl(S){let f;return{c(){f=r("triangle primitives")},l(p){f=a(p,"triangle primitives")},m(p,i){v(p,f,i)},d(p){p&&t(f)}}}function il(S){let f;return{c(){f=r("here")},l(p){f=a(p,"here")},m(p,i){v(p,f,i)},d(p){p&&t(f)}}}function cl(S){let f,p,i,P,u,A,c,h,R,x,$,E,k,O,ne,Qe,z,Ue,oe,Ne,V,Je,H,Me,fe,Re,T,Ke,B,Xe,pe,ke,I,ee,Ye,L,ie,Ze,ce,te,ve,me,ue,et,de,re,tt,he,D,rt,Ee,ae,at,le,lt,st,Ae,b,nt,q,ot,xe,d,g,ye,W,N,it,Ve,ct,vt,Te,ut,dt,ft,we,G,Le,be,ht,_e,Ge,Se,_t,$t,Fe,C,mt,Et,$e,At,hr,_r,Kt,De,$r,Wt,mr,Er,Xt,yt,qe,F,wt,Ar,bt,yr,St,wr,Pt,br,gt,Sr,It,Pr,Nt,gr,Rt,Ir,kt,Nr,xt,Rr,Vt,kr,xr,Pe,Tt,Vr,Lt,Tr,Gt,Lr,Ft,Gr,Dt,Fr,Dr,Yt,se,Ct,qr,Wr,Ot,Cr,Or,zt,zr,Hr,Zt,j,Br,Ht,jr,Qr,Bt,Ur,Jr,jt,Mr,Kr,er,We,Xr,Ce,Yr,tr,Oe,Zr,Qt,ea,ta,rr,ze,ra,He,aa,ar;return f=new Ya({props:{id:"arbitrary-sized",$$slots:{default:[fl]},$$scope:{ctx:S}}}),Ce=new dr({props:{href:"https://www.khronos.org/opengl/wiki/Primitive",$$slots:{default:[pl]},$$scope:{ctx:S}}}),He=new dr({props:{href:"https://gist.github.com/lorenzored98/56dce409d510417042ccdc97c1f3f72a",$$slots:{default:[il]},$$scope:{ctx:S}}}),{c(){J(f.$$.fragment),p=y(),i=s("p"),P=r("The way to achieve a no-buffer quad a combination of simple math, "),u=s("var"),A=r("gl_VertexID"),c=r(`
      and, `),h=s("var"),R=r("gl.TRIANGLE_STRIP"),x=r("."),$=y(),E=s("p"),k=r(`In Javascript land the only thing that changes from a hello-triangle WebGL
      program is that we call
      `),O=s("var"),ne=r("gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)"),Qe=r(`. Right now, interpret
      this as sending `),z=s("var"),Ue=r("4"),oe=r(" nonexistent vertices to the vertex shader."),Ne=y(),V=s("p"),Je=r("Note that we don't even need to bind a "),H=s("var"),Me=r("VAO"),fe=r(` in WebGL. In OpenGL you
      do need to bind it, but you can just create an empty one, and it will work.`),Re=y(),T=s("p"),Ke=r("In the vertex shader "),B=s("var"),Xe=r("gl_VertexID"),pe=r(` is the zero-based integer index
      of the current vertex. By interpreting the index as a 2-bit binary number we
      get:`),ke=y(),I=s("ul"),ee=s("li"),Ye=r("Index 0 = "),L=s("var"),ie=r("0b00"),Ze=r(" = bottom-left"),ce=y(),te=s("li"),ve=r("Index 1 = "),me=s("var"),ue=r("0b01"),et=r(" = bottom-right"),de=y(),re=s("li"),tt=r("Index 2 = "),he=s("var"),D=r("0b10"),rt=r(" = top-left"),Ee=y(),ae=s("li"),at=r("Index 3 = "),le=s("var"),lt=r("0b11"),st=r(" = top-right"),Ae=y(),b=s("p"),nt=r("We can easily get the UV coordinates from this data by using a binary "),q=s("var"),ot=r("AND"),xe=r(`
      with `),d=s("var"),g=r("1"),ye=r(" to compute the "),W=s("var"),N=r("u"),it=r(`
      and a
      `),Ve=s("var"),ct=r("RIGHT SHIFT"),vt=r(" by 1 to compute the "),Te=s("var"),ut=r("v"),dt=r("."),ft=y(),we=s("pre"),G=s("code"),Le=s("span"),be=s("span"),ht=r("2---3    0 = 00  | x = (00 & 01) = 0   |  y = (00 >> 1) = 0"),_e=r(`
`),Ge=s("span"),Se=s("span"),_t=r("|\\  |    1 = 01  | x = (01 & 01) = 1   |  y = (01 >> 1) = 0"),$t=r(`
`),Fe=s("span"),C=s("span"),mt=r("| \\ |    2 = 10  | x = (10 & 01) = 0   |  y = (10 >> 1) = 1"),Et=r(`
`),$e=s("span"),At=s("span"),hr=r("0---1    3 = 11  | x = (11 & 01) = 1   |  y = (11 >> 1) = 1"),_r=r(`
`),Kt=y(),De=s("p"),$r=r("Remapping the uv to a "),Wt=s("var"),mr=r("[-1, 1]"),Er=r(" range computes a fullscreen quad."),Xt=y(),yt=s("pre"),qe=s("code"),F=s("span"),wt=s("span"),Ar=r("vec2 uv = "),bt=s("span"),yr=r("vec2"),St=s("span"),wr=r("("),Pt=s("span"),br=r("float"),gt=s("span"),Sr=r("(gl_VertexID & "),It=s("span"),Pr=r("1"),Nt=s("span"),gr=r("), "),Rt=s("span"),Ir=r("float"),kt=s("span"),Nr=r("(gl_VertexID >> "),xt=s("span"),Rr=r("1"),Vt=s("span"),kr=r("));"),xr=r(`
`),Pe=s("span"),Tt=s("span"),Vr=r("vec2 pos = uv * "),Lt=s("span"),Tr=r("2.0"),Gt=s("span"),Lr=r(" - "),Ft=s("span"),Gr=r("1.0"),Dt=s("span"),Fr=r(";"),Dr=r(`
`),Yt=y(),se=s("p"),Ct=s("var"),qr=r("gl.TRIANGLE_STRIP"),Wr=r(` is the key to making this work. This triangle
      primitive will use vertices `),Ot=s("var"),Cr=r("[0, 1, 2]"),Or=r(` and vertices
      `),zt=s("var"),zr=r("[1, 2, 3]"),Hr=r(" to draw the triangles."),Zt=y(),j=s("p"),Br=r("Vertices "),Ht=s("var"),jr=r("[1, 2, 3]"),Qr=r(`
      do not respect the correct winding order, luckily
      `),Bt=s("var"),Ur=r("gl.TRIANGLE_STRIP"),Jr=r(`
      draw order will be reversed for every triangle beside the first, effectively
      drawing in this case `),jt=s("var"),Mr=r("[2, 1, 3]"),Kr=r("."),er=y(),We=s("p"),Xr=r(`Other modes do not follow the same rules and vertex order, so it won't
      work. Check out the
      `),J(Ce.$$.fragment),Yr=r(" section on the wiki for more details."),tr=y(),Oe=s("p"),Zr=r(`Note that this is a full-fledged quad, we can apply any transform we want
      to the newly created vertices. It also works with any number of quads,
      just make sure to use the right amount of vertices in `),Qt=s("var"),ea=r("gl.drawArrays()"),ta=r("."),rr=y(),ze=s("p"),ra=r("Source code "),J(He.$$.fragment),aa=r("."),this.h()},l(l){M(f.$$.fragment,l),p=w(l),i=n(l,"P",{});var _=o(i);P=a(_,"The way to achieve a no-buffer quad a combination of simple math, "),u=n(_,"VAR",{});var Ut=o(u);A=a(Ut,"gl_VertexID"),Ut.forEach(t),c=a(_,`
      and, `),h=n(_,"VAR",{});var Jt=o(h);R=a(Jt,"gl.TRIANGLE_STRIP"),Jt.forEach(t),x=a(_,"."),_.forEach(t),$=w(l),E=n(l,"P",{});var ge=o(E);k=a(ge,`In Javascript land the only thing that changes from a hello-triangle WebGL
      program is that we call
      `),O=n(ge,"VAR",{});var sa=o(O);ne=a(sa,"gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)"),sa.forEach(t),Qe=a(ge,`. Right now, interpret
      this as sending `),z=n(ge,"VAR",{});var na=o(z);Ue=a(na,"4"),na.forEach(t),oe=a(ge," nonexistent vertices to the vertex shader."),ge.forEach(t),Ne=w(l),V=n(l,"P",{});var lr=o(V);Je=a(lr,"Note that we don't even need to bind a "),H=n(lr,"VAR",{});var oa=o(H);Me=a(oa,"VAO"),oa.forEach(t),fe=a(lr,` in WebGL. In OpenGL you
      do need to bind it, but you can just create an empty one, and it will work.`),lr.forEach(t),Re=w(l),T=n(l,"P",{});var sr=o(T);Ke=a(sr,"In the vertex shader "),B=n(sr,"VAR",{});var fa=o(B);Xe=a(fa,"gl_VertexID"),fa.forEach(t),pe=a(sr,` is the zero-based integer index
      of the current vertex. By interpreting the index as a 2-bit binary number we
      get:`),sr.forEach(t),ke=w(l),I=n(l,"UL",{});var Be=o(I);ee=n(Be,"LI",{});var nr=o(ee);Ye=a(nr,"Index 0 = "),L=n(nr,"VAR",{});var pa=o(L);ie=a(pa,"0b00"),pa.forEach(t),Ze=a(nr," = bottom-left"),nr.forEach(t),ce=w(Be),te=n(Be,"LI",{});var or=o(te);ve=a(or,"Index 1 = "),me=n(or,"VAR",{});var ia=o(me);ue=a(ia,"0b01"),ia.forEach(t),et=a(or," = bottom-right"),or.forEach(t),de=w(Be),re=n(Be,"LI",{});var fr=o(re);tt=a(fr,"Index 2 = "),he=n(fr,"VAR",{});var ca=o(he);D=a(ca,"0b10"),ca.forEach(t),rt=a(fr," = top-left"),fr.forEach(t),Ee=w(Be),ae=n(Be,"LI",{});var pr=o(ae);at=a(pr,"Index 3 = "),le=n(pr,"VAR",{});var va=o(le);lt=a(va,"0b11"),va.forEach(t),st=a(pr," = top-right"),pr.forEach(t),Be.forEach(t),Ae=w(l),b=n(l,"P",{});var Q=o(b);nt=a(Q,"We can easily get the UV coordinates from this data by using a binary "),q=n(Q,"VAR",{});var ua=o(q);ot=a(ua,"AND"),ua.forEach(t),xe=a(Q,`
      with `),d=n(Q,"VAR",{});var da=o(d);g=a(da,"1"),da.forEach(t),ye=a(Q," to compute the "),W=n(Q,"VAR",{});var ha=o(W);N=a(ha,"u"),ha.forEach(t),it=a(Q,`
      and a
      `),Ve=n(Q,"VAR",{});var _a=o(Ve);ct=a(_a,"RIGHT SHIFT"),_a.forEach(t),vt=a(Q," by 1 to compute the "),Te=n(Q,"VAR",{});var $a=o(Te);ut=a($a,"v"),$a.forEach(t),dt=a(Q,"."),Q.forEach(t),ft=w(l),we=n(l,"PRE",{});var ma=o(we);G=n(ma,"CODE",{});var Ie=o(G);Le=n(Ie,"SPAN",{});var Ea=o(Le);be=n(Ea,"SPAN",{style:!0});var Aa=o(be);ht=a(Aa,"2---3    0 = 00  | x = (00 & 01) = 0   |  y = (00 >> 1) = 0"),Aa.forEach(t),Ea.forEach(t),_e=a(Ie,`
`),Ge=n(Ie,"SPAN",{});var ya=o(Ge);Se=n(ya,"SPAN",{style:!0});var wa=o(Se);_t=a(wa,"|\\  |    1 = 01  | x = (01 & 01) = 1   |  y = (01 >> 1) = 0"),wa.forEach(t),ya.forEach(t),$t=a(Ie,`
`),Fe=n(Ie,"SPAN",{});var ba=o(Fe);C=n(ba,"SPAN",{style:!0});var Sa=o(C);mt=a(Sa,"| \\ |    2 = 10  | x = (10 & 01) = 0   |  y = (10 >> 1) = 1"),Sa.forEach(t),ba.forEach(t),Et=a(Ie,`
`),$e=n(Ie,"SPAN",{});var Pa=o($e);At=n(Pa,"SPAN",{style:!0});var ga=o(At);hr=a(ga,"0---1    3 = 11  | x = (11 & 01) = 1   |  y = (11 >> 1) = 1"),ga.forEach(t),Pa.forEach(t),_r=a(Ie,`
`),Ie.forEach(t),ma.forEach(t),Kt=w(l),De=n(l,"P",{});var ir=o(De);$r=a(ir,"Remapping the uv to a "),Wt=n(ir,"VAR",{});var Ia=o(Wt);mr=a(Ia,"[-1, 1]"),Ia.forEach(t),Er=a(ir," range computes a fullscreen quad."),ir.forEach(t),Xt=w(l),yt=n(l,"PRE",{});var Na=o(yt);qe=n(Na,"CODE",{});var Mt=o(qe);F=n(Mt,"SPAN",{});var U=o(F);wt=n(U,"SPAN",{style:!0});var Ra=o(wt);Ar=a(Ra,"vec2 uv = "),Ra.forEach(t),bt=n(U,"SPAN",{style:!0});var ka=o(bt);yr=a(ka,"vec2"),ka.forEach(t),St=n(U,"SPAN",{style:!0});var xa=o(St);wr=a(xa,"("),xa.forEach(t),Pt=n(U,"SPAN",{style:!0});var Va=o(Pt);br=a(Va,"float"),Va.forEach(t),gt=n(U,"SPAN",{style:!0});var Ta=o(gt);Sr=a(Ta,"(gl_VertexID & "),Ta.forEach(t),It=n(U,"SPAN",{style:!0});var La=o(It);Pr=a(La,"1"),La.forEach(t),Nt=n(U,"SPAN",{style:!0});var Ga=o(Nt);gr=a(Ga,"), "),Ga.forEach(t),Rt=n(U,"SPAN",{style:!0});var Fa=o(Rt);Ir=a(Fa,"float"),Fa.forEach(t),kt=n(U,"SPAN",{style:!0});var Da=o(kt);Nr=a(Da,"(gl_VertexID >> "),Da.forEach(t),xt=n(U,"SPAN",{style:!0});var qa=o(xt);Rr=a(qa,"1"),qa.forEach(t),Vt=n(U,"SPAN",{style:!0});var Wa=o(Vt);kr=a(Wa,"));"),Wa.forEach(t),U.forEach(t),xr=a(Mt,`
`),Pe=n(Mt,"SPAN",{});var qt=o(Pe);Tt=n(qt,"SPAN",{style:!0});var Ca=o(Tt);Vr=a(Ca,"vec2 pos = uv * "),Ca.forEach(t),Lt=n(qt,"SPAN",{style:!0});var Oa=o(Lt);Tr=a(Oa,"2.0"),Oa.forEach(t),Gt=n(qt,"SPAN",{style:!0});var za=o(Gt);Lr=a(za," - "),za.forEach(t),Ft=n(qt,"SPAN",{style:!0});var Ha=o(Ft);Gr=a(Ha,"1.0"),Ha.forEach(t),Dt=n(qt,"SPAN",{style:!0});var Ba=o(Dt);Fr=a(Ba,";"),Ba.forEach(t),qt.forEach(t),Dr=a(Mt,`
`),Mt.forEach(t),Na.forEach(t),Yt=w(l),se=n(l,"P",{});var pt=o(se);Ct=n(pt,"VAR",{});var ja=o(Ct);qr=a(ja,"gl.TRIANGLE_STRIP"),ja.forEach(t),Wr=a(pt,` is the key to making this work. This triangle
      primitive will use vertices `),Ot=n(pt,"VAR",{});var Qa=o(Ot);Cr=a(Qa,"[0, 1, 2]"),Qa.forEach(t),Or=a(pt,` and vertices
      `),zt=n(pt,"VAR",{});var Ua=o(zt);zr=a(Ua,"[1, 2, 3]"),Ua.forEach(t),Hr=a(pt," to draw the triangles."),pt.forEach(t),Zt=w(l),j=n(l,"P",{});var je=o(j);Br=a(je,"Vertices "),Ht=n(je,"VAR",{});var Ja=o(Ht);jr=a(Ja,"[1, 2, 3]"),Ja.forEach(t),Qr=a(je,`
      do not respect the correct winding order, luckily
      `),Bt=n(je,"VAR",{});var Ma=o(Bt);Ur=a(Ma,"gl.TRIANGLE_STRIP"),Ma.forEach(t),Jr=a(je,`
      draw order will be reversed for every triangle beside the first, effectively
      drawing in this case `),jt=n(je,"VAR",{});var Ka=o(jt);Mr=a(Ka,"[2, 1, 3]"),Ka.forEach(t),Kr=a(je,"."),je.forEach(t),er=w(l),We=n(l,"P",{});var cr=o(We);Xr=a(cr,`Other modes do not follow the same rules and vertex order, so it won't
      work. Check out the
      `),M(Ce.$$.fragment,cr),Yr=a(cr," section on the wiki for more details."),cr.forEach(t),tr=w(l),Oe=n(l,"P",{});var vr=o(Oe);Zr=a(vr,`Note that this is a full-fledged quad, we can apply any transform we want
      to the newly created vertices. It also works with any number of quads,
      just make sure to use the right amount of vertices in `),Qt=n(vr,"VAR",{});var Xa=o(Qt);ea=a(Xa,"gl.drawArrays()"),Xa.forEach(t),ta=a(vr,"."),vr.forEach(t),rr=w(l),ze=n(l,"P",{});var ur=o(ze);ra=a(ur,"Source code "),M(He.$$.fragment,ur),aa=a(ur,"."),ur.forEach(t),this.h()},h(){m(be,"color","undefined"),m(Se,"color","undefined"),m(C,"color","undefined"),m(At,"color","undefined"),m(wt,"color","#24292F"),m(bt,"color","#0550AE"),m(St,"color","#24292F"),m(Pt,"color","#CF222E"),m(gt,"color","#24292F"),m(It,"color","#0550AE"),m(Nt,"color","#24292F"),m(Rt,"color","#CF222E"),m(kt,"color","#24292F"),m(xt,"color","#0550AE"),m(Vt,"color","#24292F"),m(Tt,"color","#24292F"),m(Lt,"color","#0550AE"),m(Gt,"color","#24292F"),m(Ft,"color","#0550AE"),m(Dt,"color","#24292F")},m(l,_){K(f,l,_),v(l,p,_),v(l,i,_),e(i,P),e(i,u),e(u,A),e(i,c),e(i,h),e(h,R),e(i,x),v(l,$,_),v(l,E,_),e(E,k),e(E,O),e(O,ne),e(E,Qe),e(E,z),e(z,Ue),e(E,oe),v(l,Ne,_),v(l,V,_),e(V,Je),e(V,H),e(H,Me),e(V,fe),v(l,Re,_),v(l,T,_),e(T,Ke),e(T,B),e(B,Xe),e(T,pe),v(l,ke,_),v(l,I,_),e(I,ee),e(ee,Ye),e(ee,L),e(L,ie),e(ee,Ze),e(I,ce),e(I,te),e(te,ve),e(te,me),e(me,ue),e(te,et),e(I,de),e(I,re),e(re,tt),e(re,he),e(he,D),e(re,rt),e(I,Ee),e(I,ae),e(ae,at),e(ae,le),e(le,lt),e(ae,st),v(l,Ae,_),v(l,b,_),e(b,nt),e(b,q),e(q,ot),e(b,xe),e(b,d),e(d,g),e(b,ye),e(b,W),e(W,N),e(b,it),e(b,Ve),e(Ve,ct),e(b,vt),e(b,Te),e(Te,ut),e(b,dt),v(l,ft,_),v(l,we,_),e(we,G),e(G,Le),e(Le,be),e(be,ht),e(G,_e),e(G,Ge),e(Ge,Se),e(Se,_t),e(G,$t),e(G,Fe),e(Fe,C),e(C,mt),e(G,Et),e(G,$e),e($e,At),e(At,hr),e(G,_r),v(l,Kt,_),v(l,De,_),e(De,$r),e(De,Wt),e(Wt,mr),e(De,Er),v(l,Xt,_),v(l,yt,_),e(yt,qe),e(qe,F),e(F,wt),e(wt,Ar),e(F,bt),e(bt,yr),e(F,St),e(St,wr),e(F,Pt),e(Pt,br),e(F,gt),e(gt,Sr),e(F,It),e(It,Pr),e(F,Nt),e(Nt,gr),e(F,Rt),e(Rt,Ir),e(F,kt),e(kt,Nr),e(F,xt),e(xt,Rr),e(F,Vt),e(Vt,kr),e(qe,xr),e(qe,Pe),e(Pe,Tt),e(Tt,Vr),e(Pe,Lt),e(Lt,Tr),e(Pe,Gt),e(Gt,Lr),e(Pe,Ft),e(Ft,Gr),e(Pe,Dt),e(Dt,Fr),e(qe,Dr),v(l,Yt,_),v(l,se,_),e(se,Ct),e(Ct,qr),e(se,Wr),e(se,Ot),e(Ot,Cr),e(se,Or),e(se,zt),e(zt,zr),e(se,Hr),v(l,Zt,_),v(l,j,_),e(j,Br),e(j,Ht),e(Ht,jr),e(j,Qr),e(j,Bt),e(Bt,Ur),e(j,Jr),e(j,jt),e(jt,Mr),e(j,Kr),v(l,er,_),v(l,We,_),e(We,Xr),K(Ce,We,null),e(We,Yr),v(l,tr,_),v(l,Oe,_),e(Oe,Zr),e(Oe,Qt),e(Qt,ea),e(Oe,ta),v(l,rr,_),v(l,ze,_),e(ze,ra),K(He,ze,null),e(ze,aa),ar=!0},p(l,_){const Ut={};_&1&&(Ut.$$scope={dirty:_,ctx:l}),f.$set(Ut);const Jt={};_&1&&(Jt.$$scope={dirty:_,ctx:l}),Ce.$set(Jt);const ge={};_&1&&(ge.$$scope={dirty:_,ctx:l}),He.$set(ge)},i(l){ar||(X(f.$$.fragment,l),X(Ce.$$.fragment,l),X(He.$$.fragment,l),ar=!0)},o(l){Y(f.$$.fragment,l),Y(Ce.$$.fragment,l),Y(He.$$.fragment,l),ar=!1},d(l){Z(f,l),l&&t(p),l&&t(i),l&&t($),l&&t(E),l&&t(Ne),l&&t(V),l&&t(Re),l&&t(T),l&&t(ke),l&&t(I),l&&t(Ae),l&&t(b),l&&t(ft),l&&t(we),l&&t(Kt),l&&t(De),l&&t(Xt),l&&t(yt),l&&t(Yt),l&&t(se),l&&t(Zt),l&&t(j),l&&t(er),l&&t(We),Z(Ce),l&&t(tr),l&&t(Oe),l&&t(rr),l&&t(ze),Z(He)}}}function vl(S){let f;return{c(){f=r("Full screen only")},l(p){f=a(p,"Full screen only")},m(p,i){v(p,f,i)},d(p){p&&t(f)}}}function ul(S){let f;return{c(){f=r("here")},l(p){f=a(p,"here")},m(p,i){v(p,f,i)},d(p){p&&t(f)}}}function dl(S){let f,p,i,P,u,A,c,h,R,x,$,E,k,O,ne,Qe,z,Ue,oe,Ne,V,Je,H,Me,fe,Re,T,Ke,B,Xe,pe,ke,I,ee,Ye,L,ie,Ze,ce,te,ve,me,ue,et,de,re,tt,he,D,rt,Ee,ae,at,le,lt,st,Ae,b,nt,q,ot,xe;return f=new Ya({props:{id:"full-screen-only",$$slots:{default:[vl]},$$scope:{ctx:S}}}),q=new dr({props:{href:"https://gist.github.com/lorenzored98/7d7c4bc862f211da0a76954b4b3870eb",$$slots:{default:[ul]},$$scope:{ctx:S}}}),{c(){J(f.$$.fragment),p=y(),i=s("p"),P=r(`If we are only ever going to need a fullscreen quad, there is an even
      simpler version that uses only 3 vertices to create a big triangle and
      computes the uv coordinates so that they form a fullscreen quad.`),u=y(),A=s("pre"),c=s("code"),h=s("span"),R=s("span"),x=r("vec2 uv = "),$=s("span"),E=r("vec2"),k=s("span"),O=r("("),ne=s("span"),Qe=r("float"),z=s("span"),Ue=r("(gl_VertexID & "),oe=s("span"),Ne=r("1"),V=s("span"),Je=r("), "),H=s("span"),Me=r("float"),fe=s("span"),Re=r("(gl_VertexID >> "),T=s("span"),Ke=r("1"),B=s("span"),Xe=r(")) * "),pe=s("span"),ke=r("2.0"),I=s("span"),ee=r(";"),Ye=r(`
`),L=s("span"),ie=s("span"),Ze=r("vec2 pos = uv * "),ce=s("span"),te=r("2.0"),ve=s("span"),me=r(" - "),ue=s("span"),et=r("1.0"),de=s("span"),re=r(";"),tt=r(`
`),he=y(),D=s("p"),rt=r("Since we only need 3 vertices for a triangle, it's not necessary to use "),Ee=s("var"),ae=r("gl.TRIANGLE_STRIP"),at=r(`, the classic
      `),le=s("var"),lt=r("gl.drawArrays(gl.TRIANGLES, 0, 3)"),st=r(" works."),Ae=y(),b=s("p"),nt=r("Source code "),J(q.$$.fragment),ot=r("."),this.h()},l(d){M(f.$$.fragment,d),p=w(d),i=n(d,"P",{});var g=o(i);P=a(g,`If we are only ever going to need a fullscreen quad, there is an even
      simpler version that uses only 3 vertices to create a big triangle and
      computes the uv coordinates so that they form a fullscreen quad.`),g.forEach(t),u=w(d),A=n(d,"PRE",{});var ye=o(A);c=n(ye,"CODE",{});var W=o(c);h=n(W,"SPAN",{});var N=o(h);R=n(N,"SPAN",{style:!0});var it=o(R);x=a(it,"vec2 uv = "),it.forEach(t),$=n(N,"SPAN",{style:!0});var Ve=o($);E=a(Ve,"vec2"),Ve.forEach(t),k=n(N,"SPAN",{style:!0});var ct=o(k);O=a(ct,"("),ct.forEach(t),ne=n(N,"SPAN",{style:!0});var vt=o(ne);Qe=a(vt,"float"),vt.forEach(t),z=n(N,"SPAN",{style:!0});var Te=o(z);Ue=a(Te,"(gl_VertexID & "),Te.forEach(t),oe=n(N,"SPAN",{style:!0});var ut=o(oe);Ne=a(ut,"1"),ut.forEach(t),V=n(N,"SPAN",{style:!0});var dt=o(V);Je=a(dt,"), "),dt.forEach(t),H=n(N,"SPAN",{style:!0});var ft=o(H);Me=a(ft,"float"),ft.forEach(t),fe=n(N,"SPAN",{style:!0});var we=o(fe);Re=a(we,"(gl_VertexID >> "),we.forEach(t),T=n(N,"SPAN",{style:!0});var G=o(T);Ke=a(G,"1"),G.forEach(t),B=n(N,"SPAN",{style:!0});var Le=o(B);Xe=a(Le,")) * "),Le.forEach(t),pe=n(N,"SPAN",{style:!0});var be=o(pe);ke=a(be,"2.0"),be.forEach(t),I=n(N,"SPAN",{style:!0});var ht=o(I);ee=a(ht,";"),ht.forEach(t),N.forEach(t),Ye=a(W,`
`),L=n(W,"SPAN",{});var _e=o(L);ie=n(_e,"SPAN",{style:!0});var Ge=o(ie);Ze=a(Ge,"vec2 pos = uv * "),Ge.forEach(t),ce=n(_e,"SPAN",{style:!0});var Se=o(ce);te=a(Se,"2.0"),Se.forEach(t),ve=n(_e,"SPAN",{style:!0});var _t=o(ve);me=a(_t," - "),_t.forEach(t),ue=n(_e,"SPAN",{style:!0});var $t=o(ue);et=a($t,"1.0"),$t.forEach(t),de=n(_e,"SPAN",{style:!0});var Fe=o(de);re=a(Fe,";"),Fe.forEach(t),_e.forEach(t),tt=a(W,`
`),W.forEach(t),ye.forEach(t),he=w(d),D=n(d,"P",{});var C=o(D);rt=a(C,"Since we only need 3 vertices for a triangle, it's not necessary to use "),Ee=n(C,"VAR",{});var mt=o(Ee);ae=a(mt,"gl.TRIANGLE_STRIP"),mt.forEach(t),at=a(C,`, the classic
      `),le=n(C,"VAR",{});var Et=o(le);lt=a(Et,"gl.drawArrays(gl.TRIANGLES, 0, 3)"),Et.forEach(t),st=a(C," works."),C.forEach(t),Ae=w(d),b=n(d,"P",{});var $e=o(b);nt=a($e,"Source code "),M(q.$$.fragment,$e),ot=a($e,"."),$e.forEach(t),this.h()},h(){m(R,"color","#24292F"),m($,"color","#0550AE"),m(k,"color","#24292F"),m(ne,"color","#CF222E"),m(z,"color","#24292F"),m(oe,"color","#0550AE"),m(V,"color","#24292F"),m(H,"color","#CF222E"),m(fe,"color","#24292F"),m(T,"color","#0550AE"),m(B,"color","#24292F"),m(pe,"color","#0550AE"),m(I,"color","#24292F"),m(ie,"color","#24292F"),m(ce,"color","#0550AE"),m(ve,"color","#24292F"),m(ue,"color","#0550AE"),m(de,"color","#24292F")},m(d,g){K(f,d,g),v(d,p,g),v(d,i,g),e(i,P),v(d,u,g),v(d,A,g),e(A,c),e(c,h),e(h,R),e(R,x),e(h,$),e($,E),e(h,k),e(k,O),e(h,ne),e(ne,Qe),e(h,z),e(z,Ue),e(h,oe),e(oe,Ne),e(h,V),e(V,Je),e(h,H),e(H,Me),e(h,fe),e(fe,Re),e(h,T),e(T,Ke),e(h,B),e(B,Xe),e(h,pe),e(pe,ke),e(h,I),e(I,ee),e(c,Ye),e(c,L),e(L,ie),e(ie,Ze),e(L,ce),e(ce,te),e(L,ve),e(ve,me),e(L,ue),e(ue,et),e(L,de),e(de,re),e(c,tt),v(d,he,g),v(d,D,g),e(D,rt),e(D,Ee),e(Ee,ae),e(D,at),e(D,le),e(le,lt),e(D,st),v(d,Ae,g),v(d,b,g),e(b,nt),K(q,b,null),e(b,ot),xe=!0},p(d,g){const ye={};g&1&&(ye.$$scope={dirty:g,ctx:d}),f.$set(ye);const W={};g&1&&(W.$$scope={dirty:g,ctx:d}),q.$set(W)},i(d){xe||(X(f.$$.fragment,d),X(q.$$.fragment,d),xe=!0)},o(d){Y(f.$$.fragment,d),Y(q.$$.fragment,d),xe=!1},d(d){Z(f,d),d&&t(p),d&&t(i),d&&t(u),d&&t(A),d&&t(he),d&&t(D),d&&t(Ae),d&&t(b),Z(q)}}}function hl(S){let f,p,i,P,u,A;return f=new la({props:{$$slots:{default:[ol]},$$scope:{ctx:S}}}),i=new la({props:{$$slots:{default:[cl]},$$scope:{ctx:S}}}),u=new la({props:{$$slots:{default:[dl]},$$scope:{ctx:S}}}),{c(){J(f.$$.fragment),p=y(),J(i.$$.fragment),P=y(),J(u.$$.fragment)},l(c){M(f.$$.fragment,c),p=w(c),M(i.$$.fragment,c),P=w(c),M(u.$$.fragment,c)},m(c,h){K(f,c,h),v(c,p,h),K(i,c,h),v(c,P,h),K(u,c,h),A=!0},p(c,h){const R={};h&1&&(R.$$scope={dirty:h,ctx:c}),f.$set(R);const x={};h&1&&(x.$$scope={dirty:h,ctx:c}),i.$set(x);const $={};h&1&&($.$$scope={dirty:h,ctx:c}),u.$set($)},i(c){A||(X(f.$$.fragment,c),X(i.$$.fragment,c),X(u.$$.fragment,c),A=!0)},o(c){Y(f.$$.fragment,c),Y(i.$$.fragment,c),Y(u.$$.fragment,c),A=!1},d(c){Z(f,c),c&&t(p),Z(i,c),c&&t(P),Z(u,c)}}}function _l(S){let f,p,i,P;return f=new ll({props:{title:"Quad Without Vertex Buffer",description:"WebGL Quad without vertex buffer trick",keywords:"Javascript, WebGL2, Gamedev, Shaders, GPU, Geometry, Instancing, Tricks, Triangle Strip"}}),i=new rl({props:{$$slots:{default:[hl]},$$scope:{ctx:S}}}),{c(){J(f.$$.fragment),p=y(),J(i.$$.fragment)},l(u){M(f.$$.fragment,u),p=w(u),M(i.$$.fragment,u)},m(u,A){K(f,u,A),v(u,p,A),K(i,u,A),P=!0},p(u,[A]){const c={};A&1&&(c.$$scope={dirty:A,ctx:u}),i.$set(c)},i(u){P||(X(f.$$.fragment,u),X(i.$$.fragment,u),P=!0)},o(u){Y(f.$$.fragment,u),Y(i.$$.fragment,u),P=!1},d(u){Z(f,u),u&&t(p),Z(i,u)}}}class wl extends Za{constructor(f){super(),el(this,f,null,_l,tl,{})}}export{wl as default};
