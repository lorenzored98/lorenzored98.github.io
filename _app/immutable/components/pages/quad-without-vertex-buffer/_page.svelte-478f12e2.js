import{S as Ya,i as Za,s as es,w as Z,a as w,x as ee,c as b,y as te,b as v,f as re,t as ae,z as se,h as t,k as l,q as r,l as n,m as o,r as a,G as e,p as m}from"../../../chunks/index-cc72a6df.js";import{B as vr}from"../../../chunks/BlankLink-67e3b987.js";import{M as ts,S as aa,T as rs}from"../../../chunks/Main-eb1110b0.js";import{S as Xa}from"../../../chunks/Subtitle-8c0c7f17.js";import{S as as}from"../../../chunks/Seo-89a4dbfb.js";function ss(y){let f;return{c(){f=r("Quad without vertex buffer")},l(i){f=a(i,"Quad without vertex buffer")},m(i,p){v(i,f,p)},d(i){i&&t(f)}}}function ls(y){let f;return{c(){f=r("repo")},l(i){f=a(i,"repo")},m(i,p){v(i,f,p)},d(i){i&&t(f)}}}function ns(y){let f,i,p,S,u,A,c,d,I,V;return f=new rs({props:{timestamp:1668709650,$$slots:{default:[ss]},$$scope:{ctx:y}}}),u=new vr({props:{href:"https://github.com/cmuratori/refterm/blob/main/refterm.hlsl#L93",$$slots:{default:[ls]},$$scope:{ctx:y}}}),{c(){Z(f.$$.fragment),i=w(),p=l("p"),S=r("While I was looking through some code on GitHub, I found a "),Z(u.$$.fragment),A=r(", that draws quads without having to populate a vertex buffer with data."),c=w(),d=l("p"),I=r(`The repo uses D3D11 and HLSL, so there are some small differences with the
      WebGL version of this post, but the core concept is the same.`)},l($){ee(f.$$.fragment,$),i=b($),p=n($,"P",{});var E=o(p);S=a(E,"While I was looking through some code on GitHub, I found a "),ee(u.$$.fragment,E),A=a(E,", that draws quads without having to populate a vertex buffer with data."),E.forEach(t),c=b($),d=n($,"P",{});var R=o(d);I=a(R,`The repo uses D3D11 and HLSL, so there are some small differences with the
      WebGL version of this post, but the core concept is the same.`),R.forEach(t)},m($,E){te(f,$,E),v($,i,E),v($,p,E),e(p,S),te(u,p,null),e(p,A),v($,c,E),v($,d,E),e(d,I),V=!0},p($,E){const R={};E&1&&(R.$$scope={dirty:E,ctx:$}),f.$set(R);const z={};E&1&&(z.$$scope={dirty:E,ctx:$}),u.$set(z)},i($){V||(re(f.$$.fragment,$),re(u.$$.fragment,$),V=!0)},o($){ae(f.$$.fragment,$),ae(u.$$.fragment,$),V=!1},d($){se(f,$),$&&t(i),$&&t(p),se(u),$&&t(c),$&&t(d)}}}function os(y){let f;return{c(){f=r("Arbitrary Sized")},l(i){f=a(i,"Arbitrary Sized")},m(i,p){v(i,f,p)},d(i){i&&t(f)}}}function fs(y){let f;return{c(){f=r("triangle primitives")},l(i){f=a(i,"triangle primitives")},m(i,p){v(i,f,p)},d(i){i&&t(f)}}}function is(y){let f;return{c(){f=r("here")},l(i){f=a(i,"here")},m(i,p){v(i,f,p)},d(i){i&&t(f)}}}function ps(y){let f,i,p,S,u,A,c,d,I,V,$,E,R,z,ie,Je,H,Me,pe,ke,x,Ke,B,Xe,ce,Ve,G,$e,ve,Ye,le,k,F,Ze,me,C,ue,et,D,tt,j,rt,de,at,q,st,Ee,xe,W,lt,O,nt,Ae,we,ot,Te,P,Q,be,U,ft,he,_,g,ne,J,N,Le,ct,vt,Ge,ut,dt,it,ye,T,Fe,Se,ht,_t,M,Pe,$t,mt,De,ge,_e,Et,qe,oe,ur,dr,Mt,We,hr,qt,_r,$r,Kt,At,Ce,L,wt,mr,bt,Er,yt,Ar,St,wr,Pt,br,gt,yr,Nt,Sr,It,Pr,Rt,gr,kt,Nr,Vt,Ir,Rr,Ne,xt,kr,Tt,Vr,Lt,xr,Gt,Tr,Ft,Lr,Gr,Xt,fe,Wt,Fr,Dr,Ct,qr,Wr,Ot,Cr,Or,Yt,K,zr,zt,Hr,Br,Ht,jr,Qr,Bt,Ur,Jr,Zt,Oe,Mr,ze,Kr,er,He,Xr,jt,Yr,Zr,tr,Be,ea,je,ta,rr;return f=new Xa({props:{id:"arbitrary-sized",$$slots:{default:[os]},$$scope:{ctx:y}}}),ze=new vr({props:{href:"https://www.khronos.org/opengl/wiki/Primitive",$$slots:{default:[fs]},$$scope:{ctx:y}}}),je=new vr({props:{href:"https://gist.github.com/lorenzored98/56dce409d510417042ccdc97c1f3f72a",$$slots:{default:[is]},$$scope:{ctx:y}}}),{c(){Z(f.$$.fragment),i=w(),p=l("p"),S=r("The way to achieve a no-buffer quad is a combination of simple math, "),u=l("var"),A=r("gl_VertexID"),c=r(`
      and, `),d=l("var"),I=r("gl.TRIANGLE_STRIP"),V=r("."),$=w(),E=l("p"),R=r(`In Javascript land the only thing that changes from a hello-triangle WebGL
      program is calling
      `),z=l("var"),ie=r("gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)"),Je=r(` in the draw function.
      Right now, interpret this as sending `),H=l("var"),Me=r("4"),pe=r(` nonexistent vertices to the
      vertex shader.`),ke=w(),x=l("p"),Ke=r("Note that we don't even need to bind a "),B=l("var"),Xe=r("VAO"),ce=r(` in WebGL. In OpenGL you
      do need to bind it, but you can just create an empty one, and it will work.`),Ve=w(),G=l("p"),$e=l("var"),ve=r("gl_VertexID"),Ye=r(` is the zero-based integer index of the current vertex
      that is being processed in the vertex shader. By interpreting the index as
      a 2-bit binary number we get:`),le=w(),k=l("ul"),F=l("li"),Ze=r("Index 0 = "),me=l("var"),C=r("0b00"),ue=r(" = bottom-left"),et=w(),D=l("li"),tt=r("Index 1 = "),j=l("var"),rt=r("0b01"),de=r(" = bottom-right"),at=w(),q=l("li"),st=r("Index 2 = "),Ee=l("var"),xe=r("0b10"),W=r(" = top-left"),lt=w(),O=l("li"),nt=r("Index 3 = "),Ae=l("var"),we=r("0b11"),ot=r(" = top-right"),Te=w(),P=l("p"),Q=r("We can easily get the UV coordinates from this data by using a binary "),be=l("var"),U=r("AND"),ft=r(`
      with `),he=l("var"),_=r("1"),g=r(" to compute the "),ne=l("var"),J=r("u"),N=r(`
      and a
      `),Le=l("var"),ct=r("RIGHT SHIFT"),vt=r(" by 1 to compute the "),Ge=l("var"),ut=r("v"),dt=r("."),it=w(),ye=l("pre"),T=l("code"),Fe=l("span"),Se=l("span"),ht=r("2---3    0 = 00  | u = (00 & 01) = 0   |  v = (00 >> 1) = 0"),_t=r(`
`),M=l("span"),Pe=l("span"),$t=r("|\\  |    1 = 01  | u = (01 & 01) = 1   |  v = (01 >> 1) = 0"),mt=r(`
`),De=l("span"),ge=l("span"),_e=r("| \\ |    2 = 10  | u = (10 & 01) = 0   |  v = (10 >> 1) = 1"),Et=r(`
`),qe=l("span"),oe=l("span"),ur=r("0---1    3 = 11  | u = (11 & 01) = 1   |  v = (11 >> 1) = 1"),dr=r(`
`),Mt=w(),We=l("p"),hr=r("Remapping the uv to a "),qt=l("var"),_r=r("[-1, 1]"),$r=r(` range computes the 4 vertices of a
      fullscreen quad.`),Kt=w(),At=l("pre"),Ce=l("code"),L=l("span"),wt=l("span"),mr=r("vec2 uv = "),bt=l("span"),Er=r("vec2"),yt=l("span"),Ar=r("("),St=l("span"),wr=r("float"),Pt=l("span"),br=r("(gl_VertexID & "),gt=l("span"),yr=r("1"),Nt=l("span"),Sr=r("), "),It=l("span"),Pr=r("float"),Rt=l("span"),gr=r("(gl_VertexID >> "),kt=l("span"),Nr=r("1"),Vt=l("span"),Ir=r("));"),Rr=r(`
`),Ne=l("span"),xt=l("span"),kr=r("vec2 pos = uv * "),Tt=l("span"),Vr=r("2.0"),Lt=l("span"),xr=r(" - "),Gt=l("span"),Tr=r("1.0"),Ft=l("span"),Lr=r(";"),Gr=r(`
`),Xt=w(),fe=l("p"),Wt=l("var"),Fr=r("gl.TRIANGLE_STRIP"),Dr=r(` is the key to making this work. This triangle
      primitive will use vertices `),Ct=l("var"),qr=r("[0, 1, 2]"),Wr=r(` and vertices
      `),Ot=l("var"),Cr=r("[1, 2, 3]"),Or=r(" to draw the triangles."),Yt=w(),K=l("p"),zr=r("Vertices "),zt=l("var"),Hr=r("[1, 2, 3]"),Br=r(`
      do not respect the correct winding order, luckily
      `),Ht=l("var"),jr=r("gl.TRIANGLE_STRIP"),Qr=r(`
      draw order will be reversed for every triangle beside the first, effectively
      drawing in this case `),Bt=l("var"),Ur=r("[2, 1, 3]"),Jr=r("."),Zt=w(),Oe=l("p"),Mr=r(`Other modes do not follow the same rules and vertex order, so it won't
      work. Check out the
      `),Z(ze.$$.fragment),Kr=r(" section on the wiki for more details."),er=w(),He=l("p"),Xr=r(`Note that this is a full-fledged quad, we can apply any transform we want
      to the newly created vertices. It also works with any number of quads,
      just make sure to use the right amount of vertices in `),jt=l("var"),Yr=r("gl.drawArrays()"),Zr=r("."),tr=w(),Be=l("p"),ea=r("Source code "),Z(je.$$.fragment),ta=r("."),this.h()},l(s){ee(f.$$.fragment,s),i=b(s),p=n(s,"P",{});var h=o(p);S=a(h,"The way to achieve a no-buffer quad is a combination of simple math, "),u=n(h,"VAR",{});var Qt=o(u);A=a(Qt,"gl_VertexID"),Qt.forEach(t),c=a(h,`
      and, `),d=n(h,"VAR",{});var Ut=o(d);I=a(Ut,"gl.TRIANGLE_STRIP"),Ut.forEach(t),V=a(h,"."),h.forEach(t),$=b(s),E=n(s,"P",{});var Ie=o(E);R=a(Ie,`In Javascript land the only thing that changes from a hello-triangle WebGL
      program is calling
      `),z=n(Ie,"VAR",{});var sa=o(z);ie=a(sa,"gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)"),sa.forEach(t),Je=a(Ie,` in the draw function.
      Right now, interpret this as sending `),H=n(Ie,"VAR",{});var la=o(H);Me=a(la,"4"),la.forEach(t),pe=a(Ie,` nonexistent vertices to the
      vertex shader.`),Ie.forEach(t),ke=b(s),x=n(s,"P",{});var ar=o(x);Ke=a(ar,"Note that we don't even need to bind a "),B=n(ar,"VAR",{});var na=o(B);Xe=a(na,"VAO"),na.forEach(t),ce=a(ar,` in WebGL. In OpenGL you
      do need to bind it, but you can just create an empty one, and it will work.`),ar.forEach(t),Ve=b(s),G=n(s,"P",{});var ra=o(G);$e=n(ra,"VAR",{});var oa=o($e);ve=a(oa,"gl_VertexID"),oa.forEach(t),Ye=a(ra,` is the zero-based integer index of the current vertex
      that is being processed in the vertex shader. By interpreting the index as
      a 2-bit binary number we get:`),ra.forEach(t),le=b(s),k=n(s,"UL",{});var Qe=o(k);F=n(Qe,"LI",{});var sr=o(F);Ze=a(sr,"Index 0 = "),me=n(sr,"VAR",{});var fa=o(me);C=a(fa,"0b00"),fa.forEach(t),ue=a(sr," = bottom-left"),sr.forEach(t),et=b(Qe),D=n(Qe,"LI",{});var lr=o(D);tt=a(lr,"Index 1 = "),j=n(lr,"VAR",{});var ia=o(j);rt=a(ia,"0b01"),ia.forEach(t),de=a(lr," = bottom-right"),lr.forEach(t),at=b(Qe),q=n(Qe,"LI",{});var nr=o(q);st=a(nr,"Index 2 = "),Ee=n(nr,"VAR",{});var pa=o(Ee);xe=a(pa,"0b10"),pa.forEach(t),W=a(nr," = top-left"),nr.forEach(t),lt=b(Qe),O=n(Qe,"LI",{});var or=o(O);nt=a(or,"Index 3 = "),Ae=n(or,"VAR",{});var ca=o(Ae);we=a(ca,"0b11"),ca.forEach(t),ot=a(or," = top-right"),or.forEach(t),Qe.forEach(t),Te=b(s),P=n(s,"P",{});var X=o(P);Q=a(X,"We can easily get the UV coordinates from this data by using a binary "),be=n(X,"VAR",{});var va=o(be);U=a(va,"AND"),va.forEach(t),ft=a(X,`
      with `),he=n(X,"VAR",{});var ua=o(he);_=a(ua,"1"),ua.forEach(t),g=a(X," to compute the "),ne=n(X,"VAR",{});var da=o(ne);J=a(da,"u"),da.forEach(t),N=a(X,`
      and a
      `),Le=n(X,"VAR",{});var ha=o(Le);ct=a(ha,"RIGHT SHIFT"),ha.forEach(t),vt=a(X," by 1 to compute the "),Ge=n(X,"VAR",{});var _a=o(Ge);ut=a(_a,"v"),_a.forEach(t),dt=a(X,"."),X.forEach(t),it=b(s),ye=n(s,"PRE",{});var $a=o(ye);T=n($a,"CODE",{});var Re=o(T);Fe=n(Re,"SPAN",{});var ma=o(Fe);Se=n(ma,"SPAN",{style:!0});var Ea=o(Se);ht=a(Ea,"2---3    0 = 00  | u = (00 & 01) = 0   |  v = (00 >> 1) = 0"),Ea.forEach(t),ma.forEach(t),_t=a(Re,`
`),M=n(Re,"SPAN",{});var Aa=o(M);Pe=n(Aa,"SPAN",{style:!0});var wa=o(Pe);$t=a(wa,"|\\  |    1 = 01  | u = (01 & 01) = 1   |  v = (01 >> 1) = 0"),wa.forEach(t),Aa.forEach(t),mt=a(Re,`
`),De=n(Re,"SPAN",{});var ba=o(De);ge=n(ba,"SPAN",{style:!0});var ya=o(ge);_e=a(ya,"| \\ |    2 = 10  | u = (10 & 01) = 0   |  v = (10 >> 1) = 1"),ya.forEach(t),ba.forEach(t),Et=a(Re,`
`),qe=n(Re,"SPAN",{});var Sa=o(qe);oe=n(Sa,"SPAN",{style:!0});var Pa=o(oe);ur=a(Pa,"0---1    3 = 11  | u = (11 & 01) = 1   |  v = (11 >> 1) = 1"),Pa.forEach(t),Sa.forEach(t),dr=a(Re,`
`),Re.forEach(t),$a.forEach(t),Mt=b(s),We=n(s,"P",{});var fr=o(We);hr=a(fr,"Remapping the uv to a "),qt=n(fr,"VAR",{});var ga=o(qt);_r=a(ga,"[-1, 1]"),ga.forEach(t),$r=a(fr,` range computes the 4 vertices of a
      fullscreen quad.`),fr.forEach(t),Kt=b(s),At=n(s,"PRE",{});var Na=o(At);Ce=n(Na,"CODE",{});var Jt=o(Ce);L=n(Jt,"SPAN",{});var Y=o(L);wt=n(Y,"SPAN",{style:!0});var Ia=o(wt);mr=a(Ia,"vec2 uv = "),Ia.forEach(t),bt=n(Y,"SPAN",{style:!0});var Ra=o(bt);Er=a(Ra,"vec2"),Ra.forEach(t),yt=n(Y,"SPAN",{style:!0});var ka=o(yt);Ar=a(ka,"("),ka.forEach(t),St=n(Y,"SPAN",{style:!0});var Va=o(St);wr=a(Va,"float"),Va.forEach(t),Pt=n(Y,"SPAN",{style:!0});var xa=o(Pt);br=a(xa,"(gl_VertexID & "),xa.forEach(t),gt=n(Y,"SPAN",{style:!0});var Ta=o(gt);yr=a(Ta,"1"),Ta.forEach(t),Nt=n(Y,"SPAN",{style:!0});var La=o(Nt);Sr=a(La,"), "),La.forEach(t),It=n(Y,"SPAN",{style:!0});var Ga=o(It);Pr=a(Ga,"float"),Ga.forEach(t),Rt=n(Y,"SPAN",{style:!0});var Fa=o(Rt);gr=a(Fa,"(gl_VertexID >> "),Fa.forEach(t),kt=n(Y,"SPAN",{style:!0});var Da=o(kt);Nr=a(Da,"1"),Da.forEach(t),Vt=n(Y,"SPAN",{style:!0});var qa=o(Vt);Ir=a(qa,"));"),qa.forEach(t),Y.forEach(t),Rr=a(Jt,`
`),Ne=n(Jt,"SPAN",{});var Dt=o(Ne);xt=n(Dt,"SPAN",{style:!0});var Wa=o(xt);kr=a(Wa,"vec2 pos = uv * "),Wa.forEach(t),Tt=n(Dt,"SPAN",{style:!0});var Ca=o(Tt);Vr=a(Ca,"2.0"),Ca.forEach(t),Lt=n(Dt,"SPAN",{style:!0});var Oa=o(Lt);xr=a(Oa," - "),Oa.forEach(t),Gt=n(Dt,"SPAN",{style:!0});var za=o(Gt);Tr=a(za,"1.0"),za.forEach(t),Ft=n(Dt,"SPAN",{style:!0});var Ha=o(Ft);Lr=a(Ha,";"),Ha.forEach(t),Dt.forEach(t),Gr=a(Jt,`
`),Jt.forEach(t),Na.forEach(t),Xt=b(s),fe=n(s,"P",{});var pt=o(fe);Wt=n(pt,"VAR",{});var Ba=o(Wt);Fr=a(Ba,"gl.TRIANGLE_STRIP"),Ba.forEach(t),Dr=a(pt,` is the key to making this work. This triangle
      primitive will use vertices `),Ct=n(pt,"VAR",{});var ja=o(Ct);qr=a(ja,"[0, 1, 2]"),ja.forEach(t),Wr=a(pt,` and vertices
      `),Ot=n(pt,"VAR",{});var Qa=o(Ot);Cr=a(Qa,"[1, 2, 3]"),Qa.forEach(t),Or=a(pt," to draw the triangles."),pt.forEach(t),Yt=b(s),K=n(s,"P",{});var Ue=o(K);zr=a(Ue,"Vertices "),zt=n(Ue,"VAR",{});var Ua=o(zt);Hr=a(Ua,"[1, 2, 3]"),Ua.forEach(t),Br=a(Ue,`
      do not respect the correct winding order, luckily
      `),Ht=n(Ue,"VAR",{});var Ja=o(Ht);jr=a(Ja,"gl.TRIANGLE_STRIP"),Ja.forEach(t),Qr=a(Ue,`
      draw order will be reversed for every triangle beside the first, effectively
      drawing in this case `),Bt=n(Ue,"VAR",{});var Ma=o(Bt);Ur=a(Ma,"[2, 1, 3]"),Ma.forEach(t),Jr=a(Ue,"."),Ue.forEach(t),Zt=b(s),Oe=n(s,"P",{});var ir=o(Oe);Mr=a(ir,`Other modes do not follow the same rules and vertex order, so it won't
      work. Check out the
      `),ee(ze.$$.fragment,ir),Kr=a(ir," section on the wiki for more details."),ir.forEach(t),er=b(s),He=n(s,"P",{});var pr=o(He);Xr=a(pr,`Note that this is a full-fledged quad, we can apply any transform we want
      to the newly created vertices. It also works with any number of quads,
      just make sure to use the right amount of vertices in `),jt=n(pr,"VAR",{});var Ka=o(jt);Yr=a(Ka,"gl.drawArrays()"),Ka.forEach(t),Zr=a(pr,"."),pr.forEach(t),tr=b(s),Be=n(s,"P",{});var cr=o(Be);ea=a(cr,"Source code "),ee(je.$$.fragment,cr),ta=a(cr,"."),cr.forEach(t),this.h()},h(){m(Se,"color","undefined"),m(Pe,"color","undefined"),m(ge,"color","undefined"),m(oe,"color","undefined"),m(wt,"color","#24292F"),m(bt,"color","#0550AE"),m(yt,"color","#24292F"),m(St,"color","#CF222E"),m(Pt,"color","#24292F"),m(gt,"color","#0550AE"),m(Nt,"color","#24292F"),m(It,"color","#CF222E"),m(Rt,"color","#24292F"),m(kt,"color","#0550AE"),m(Vt,"color","#24292F"),m(xt,"color","#24292F"),m(Tt,"color","#0550AE"),m(Lt,"color","#24292F"),m(Gt,"color","#0550AE"),m(Ft,"color","#24292F")},m(s,h){te(f,s,h),v(s,i,h),v(s,p,h),e(p,S),e(p,u),e(u,A),e(p,c),e(p,d),e(d,I),e(p,V),v(s,$,h),v(s,E,h),e(E,R),e(E,z),e(z,ie),e(E,Je),e(E,H),e(H,Me),e(E,pe),v(s,ke,h),v(s,x,h),e(x,Ke),e(x,B),e(B,Xe),e(x,ce),v(s,Ve,h),v(s,G,h),e(G,$e),e($e,ve),e(G,Ye),v(s,le,h),v(s,k,h),e(k,F),e(F,Ze),e(F,me),e(me,C),e(F,ue),e(k,et),e(k,D),e(D,tt),e(D,j),e(j,rt),e(D,de),e(k,at),e(k,q),e(q,st),e(q,Ee),e(Ee,xe),e(q,W),e(k,lt),e(k,O),e(O,nt),e(O,Ae),e(Ae,we),e(O,ot),v(s,Te,h),v(s,P,h),e(P,Q),e(P,be),e(be,U),e(P,ft),e(P,he),e(he,_),e(P,g),e(P,ne),e(ne,J),e(P,N),e(P,Le),e(Le,ct),e(P,vt),e(P,Ge),e(Ge,ut),e(P,dt),v(s,it,h),v(s,ye,h),e(ye,T),e(T,Fe),e(Fe,Se),e(Se,ht),e(T,_t),e(T,M),e(M,Pe),e(Pe,$t),e(T,mt),e(T,De),e(De,ge),e(ge,_e),e(T,Et),e(T,qe),e(qe,oe),e(oe,ur),e(T,dr),v(s,Mt,h),v(s,We,h),e(We,hr),e(We,qt),e(qt,_r),e(We,$r),v(s,Kt,h),v(s,At,h),e(At,Ce),e(Ce,L),e(L,wt),e(wt,mr),e(L,bt),e(bt,Er),e(L,yt),e(yt,Ar),e(L,St),e(St,wr),e(L,Pt),e(Pt,br),e(L,gt),e(gt,yr),e(L,Nt),e(Nt,Sr),e(L,It),e(It,Pr),e(L,Rt),e(Rt,gr),e(L,kt),e(kt,Nr),e(L,Vt),e(Vt,Ir),e(Ce,Rr),e(Ce,Ne),e(Ne,xt),e(xt,kr),e(Ne,Tt),e(Tt,Vr),e(Ne,Lt),e(Lt,xr),e(Ne,Gt),e(Gt,Tr),e(Ne,Ft),e(Ft,Lr),e(Ce,Gr),v(s,Xt,h),v(s,fe,h),e(fe,Wt),e(Wt,Fr),e(fe,Dr),e(fe,Ct),e(Ct,qr),e(fe,Wr),e(fe,Ot),e(Ot,Cr),e(fe,Or),v(s,Yt,h),v(s,K,h),e(K,zr),e(K,zt),e(zt,Hr),e(K,Br),e(K,Ht),e(Ht,jr),e(K,Qr),e(K,Bt),e(Bt,Ur),e(K,Jr),v(s,Zt,h),v(s,Oe,h),e(Oe,Mr),te(ze,Oe,null),e(Oe,Kr),v(s,er,h),v(s,He,h),e(He,Xr),e(He,jt),e(jt,Yr),e(He,Zr),v(s,tr,h),v(s,Be,h),e(Be,ea),te(je,Be,null),e(Be,ta),rr=!0},p(s,h){const Qt={};h&1&&(Qt.$$scope={dirty:h,ctx:s}),f.$set(Qt);const Ut={};h&1&&(Ut.$$scope={dirty:h,ctx:s}),ze.$set(Ut);const Ie={};h&1&&(Ie.$$scope={dirty:h,ctx:s}),je.$set(Ie)},i(s){rr||(re(f.$$.fragment,s),re(ze.$$.fragment,s),re(je.$$.fragment,s),rr=!0)},o(s){ae(f.$$.fragment,s),ae(ze.$$.fragment,s),ae(je.$$.fragment,s),rr=!1},d(s){se(f,s),s&&t(i),s&&t(p),s&&t($),s&&t(E),s&&t(ke),s&&t(x),s&&t(Ve),s&&t(G),s&&t(le),s&&t(k),s&&t(Te),s&&t(P),s&&t(it),s&&t(ye),s&&t(Mt),s&&t(We),s&&t(Kt),s&&t(At),s&&t(Xt),s&&t(fe),s&&t(Yt),s&&t(K),s&&t(Zt),s&&t(Oe),se(ze),s&&t(er),s&&t(He),s&&t(tr),s&&t(Be),se(je)}}}function cs(y){let f;return{c(){f=r("Full screen only")},l(i){f=a(i,"Full screen only")},m(i,p){v(i,f,p)},d(i){i&&t(f)}}}function vs(y){let f;return{c(){f=r("here")},l(i){f=a(i,"here")},m(i,p){v(i,f,p)},d(i){i&&t(f)}}}function us(y){let f,i,p,S,u,A,c,d,I,V,$,E,R,z,ie,Je,H,Me,pe,ke,x,Ke,B,Xe,ce,Ve,G,$e,ve,Ye,le,k,F,Ze,me,C,ue,et,D,tt,j,rt,de,at,q,st,Ee,xe,W,lt,O,nt,Ae,we,ot,Te,P,Q,be,U,ft,he;return f=new Xa({props:{id:"full-screen-only",$$slots:{default:[cs]},$$scope:{ctx:y}}}),U=new vr({props:{href:"https://gist.github.com/lorenzored98/7d7c4bc862f211da0a76954b4b3870eb",$$slots:{default:[vs]},$$scope:{ctx:y}}}),{c(){Z(f.$$.fragment),i=w(),p=l("p"),S=r(`If we are only ever going to need a fullscreen quad, there is an even
      simpler version that uses only 3 vertices to create a big triangle and
      computes the uv coordinates so that they form a fullscreen quad.`),u=w(),A=l("pre"),c=l("code"),d=l("span"),I=l("span"),V=r("vec2 uv = "),$=l("span"),E=r("vec2"),R=l("span"),z=r("("),ie=l("span"),Je=r("float"),H=l("span"),Me=r("(gl_VertexID & "),pe=l("span"),ke=r("1"),x=l("span"),Ke=r("), "),B=l("span"),Xe=r("float"),ce=l("span"),Ve=r("(gl_VertexID >> "),G=l("span"),$e=r("1"),ve=l("span"),Ye=r(")) * "),le=l("span"),k=r("2.0"),F=l("span"),Ze=r(";"),me=r(`
`),C=l("span"),ue=l("span"),et=r("vec2 pos = uv * "),D=l("span"),tt=r("2.0"),j=l("span"),rt=r(" - "),de=l("span"),at=r("1.0"),q=l("span"),st=r(";"),Ee=r(`
`),xe=w(),W=l("p"),lt=r("Since we only need 3 vertices for a triangle, it's not necessary to use "),O=l("var"),nt=r("gl.TRIANGLE_STRIP"),Ae=r(`, the classic
      `),we=l("var"),ot=r("gl.drawArrays(gl.TRIANGLES, 0, 3)"),Te=r(" works."),P=w(),Q=l("p"),be=r("Source code "),Z(U.$$.fragment),ft=r("."),this.h()},l(_){ee(f.$$.fragment,_),i=b(_),p=n(_,"P",{});var g=o(p);S=a(g,`If we are only ever going to need a fullscreen quad, there is an even
      simpler version that uses only 3 vertices to create a big triangle and
      computes the uv coordinates so that they form a fullscreen quad.`),g.forEach(t),u=b(_),A=n(_,"PRE",{});var ne=o(A);c=n(ne,"CODE",{});var J=o(c);d=n(J,"SPAN",{});var N=o(d);I=n(N,"SPAN",{style:!0});var Le=o(I);V=a(Le,"vec2 uv = "),Le.forEach(t),$=n(N,"SPAN",{style:!0});var ct=o($);E=a(ct,"vec2"),ct.forEach(t),R=n(N,"SPAN",{style:!0});var vt=o(R);z=a(vt,"("),vt.forEach(t),ie=n(N,"SPAN",{style:!0});var Ge=o(ie);Je=a(Ge,"float"),Ge.forEach(t),H=n(N,"SPAN",{style:!0});var ut=o(H);Me=a(ut,"(gl_VertexID & "),ut.forEach(t),pe=n(N,"SPAN",{style:!0});var dt=o(pe);ke=a(dt,"1"),dt.forEach(t),x=n(N,"SPAN",{style:!0});var it=o(x);Ke=a(it,"), "),it.forEach(t),B=n(N,"SPAN",{style:!0});var ye=o(B);Xe=a(ye,"float"),ye.forEach(t),ce=n(N,"SPAN",{style:!0});var T=o(ce);Ve=a(T,"(gl_VertexID >> "),T.forEach(t),G=n(N,"SPAN",{style:!0});var Fe=o(G);$e=a(Fe,"1"),Fe.forEach(t),ve=n(N,"SPAN",{style:!0});var Se=o(ve);Ye=a(Se,")) * "),Se.forEach(t),le=n(N,"SPAN",{style:!0});var ht=o(le);k=a(ht,"2.0"),ht.forEach(t),F=n(N,"SPAN",{style:!0});var _t=o(F);Ze=a(_t,";"),_t.forEach(t),N.forEach(t),me=a(J,`
`),C=n(J,"SPAN",{});var M=o(C);ue=n(M,"SPAN",{style:!0});var Pe=o(ue);et=a(Pe,"vec2 pos = uv * "),Pe.forEach(t),D=n(M,"SPAN",{style:!0});var $t=o(D);tt=a($t,"2.0"),$t.forEach(t),j=n(M,"SPAN",{style:!0});var mt=o(j);rt=a(mt," - "),mt.forEach(t),de=n(M,"SPAN",{style:!0});var De=o(de);at=a(De,"1.0"),De.forEach(t),q=n(M,"SPAN",{style:!0});var ge=o(q);st=a(ge,";"),ge.forEach(t),M.forEach(t),Ee=a(J,`
`),J.forEach(t),ne.forEach(t),xe=b(_),W=n(_,"P",{});var _e=o(W);lt=a(_e,"Since we only need 3 vertices for a triangle, it's not necessary to use "),O=n(_e,"VAR",{});var Et=o(O);nt=a(Et,"gl.TRIANGLE_STRIP"),Et.forEach(t),Ae=a(_e,`, the classic
      `),we=n(_e,"VAR",{});var qe=o(we);ot=a(qe,"gl.drawArrays(gl.TRIANGLES, 0, 3)"),qe.forEach(t),Te=a(_e," works."),_e.forEach(t),P=b(_),Q=n(_,"P",{});var oe=o(Q);be=a(oe,"Source code "),ee(U.$$.fragment,oe),ft=a(oe,"."),oe.forEach(t),this.h()},h(){m(I,"color","#24292F"),m($,"color","#0550AE"),m(R,"color","#24292F"),m(ie,"color","#CF222E"),m(H,"color","#24292F"),m(pe,"color","#0550AE"),m(x,"color","#24292F"),m(B,"color","#CF222E"),m(ce,"color","#24292F"),m(G,"color","#0550AE"),m(ve,"color","#24292F"),m(le,"color","#0550AE"),m(F,"color","#24292F"),m(ue,"color","#24292F"),m(D,"color","#0550AE"),m(j,"color","#24292F"),m(de,"color","#0550AE"),m(q,"color","#24292F")},m(_,g){te(f,_,g),v(_,i,g),v(_,p,g),e(p,S),v(_,u,g),v(_,A,g),e(A,c),e(c,d),e(d,I),e(I,V),e(d,$),e($,E),e(d,R),e(R,z),e(d,ie),e(ie,Je),e(d,H),e(H,Me),e(d,pe),e(pe,ke),e(d,x),e(x,Ke),e(d,B),e(B,Xe),e(d,ce),e(ce,Ve),e(d,G),e(G,$e),e(d,ve),e(ve,Ye),e(d,le),e(le,k),e(d,F),e(F,Ze),e(c,me),e(c,C),e(C,ue),e(ue,et),e(C,D),e(D,tt),e(C,j),e(j,rt),e(C,de),e(de,at),e(C,q),e(q,st),e(c,Ee),v(_,xe,g),v(_,W,g),e(W,lt),e(W,O),e(O,nt),e(W,Ae),e(W,we),e(we,ot),e(W,Te),v(_,P,g),v(_,Q,g),e(Q,be),te(U,Q,null),e(Q,ft),he=!0},p(_,g){const ne={};g&1&&(ne.$$scope={dirty:g,ctx:_}),f.$set(ne);const J={};g&1&&(J.$$scope={dirty:g,ctx:_}),U.$set(J)},i(_){he||(re(f.$$.fragment,_),re(U.$$.fragment,_),he=!0)},o(_){ae(f.$$.fragment,_),ae(U.$$.fragment,_),he=!1},d(_){se(f,_),_&&t(i),_&&t(p),_&&t(u),_&&t(A),_&&t(xe),_&&t(W),_&&t(P),_&&t(Q),se(U)}}}function ds(y){let f,i,p,S,u,A;return f=new aa({props:{$$slots:{default:[ns]},$$scope:{ctx:y}}}),p=new aa({props:{$$slots:{default:[ps]},$$scope:{ctx:y}}}),u=new aa({props:{$$slots:{default:[us]},$$scope:{ctx:y}}}),{c(){Z(f.$$.fragment),i=w(),Z(p.$$.fragment),S=w(),Z(u.$$.fragment)},l(c){ee(f.$$.fragment,c),i=b(c),ee(p.$$.fragment,c),S=b(c),ee(u.$$.fragment,c)},m(c,d){te(f,c,d),v(c,i,d),te(p,c,d),v(c,S,d),te(u,c,d),A=!0},p(c,d){const I={};d&1&&(I.$$scope={dirty:d,ctx:c}),f.$set(I);const V={};d&1&&(V.$$scope={dirty:d,ctx:c}),p.$set(V);const $={};d&1&&($.$$scope={dirty:d,ctx:c}),u.$set($)},i(c){A||(re(f.$$.fragment,c),re(p.$$.fragment,c),re(u.$$.fragment,c),A=!0)},o(c){ae(f.$$.fragment,c),ae(p.$$.fragment,c),ae(u.$$.fragment,c),A=!1},d(c){se(f,c),c&&t(i),se(p,c),c&&t(S),se(u,c)}}}function hs(y){let f,i,p,S;return f=new as({props:{title:"Quad Without Vertex Buffer",description:"WebGL Quad without vertex buffer trick",keywords:"Javascript, WebGL2, Gamedev, Shaders, GPU, Geometry, Instancing, Tricks, Triangle Strip"}}),p=new ts({props:{$$slots:{default:[ds]},$$scope:{ctx:y}}}),{c(){Z(f.$$.fragment),i=w(),Z(p.$$.fragment)},l(u){ee(f.$$.fragment,u),i=b(u),ee(p.$$.fragment,u)},m(u,A){te(f,u,A),v(u,i,A),te(p,u,A),S=!0},p(u,[A]){const c={};A&1&&(c.$$scope={dirty:A,ctx:u}),p.$set(c)},i(u){S||(re(f.$$.fragment,u),re(p.$$.fragment,u),S=!0)},o(u){ae(f.$$.fragment,u),ae(p.$$.fragment,u),S=!1},d(u){se(f,u),u&&t(i),se(p,u)}}}class ws extends Ya{constructor(f){super(),Za(this,f,null,hs,es,{})}}export{ws as default};
