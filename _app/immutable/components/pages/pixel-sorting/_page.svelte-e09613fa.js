import{S as $e,i as _e,s as ve,w as H,x as K,y as J,f as Y,t as Q,z as X,o as be,k,l as T,m as P,h as c,n as U,b as M,B as we,J as re,K as pe,q as B,a as O,r as L,c as q,G as p,L as se,u as Ie,M as de,P as xe}from"../../../chunks/index-6be07ad6.js";import{B as ge}from"../../../chunks/BlankLink-db4a2256.js";import{M as Ee,S as Se,T as ke}from"../../../chunks/Main-d501f058.js";import{S as Te}from"../../../chunks/Seo-8afd16e9.js";import{r as he,g as oe}from"../../../chunks/math-4278f00e.js";import{D as Pe}from"../../../chunks/DemoContainer-02f198f6.js";import{N as ye}from"../../../chunks/NumberRange-767509e5.js";import{I as De}from"../../../chunks/ImageSelect-24d6df7c.js";function Me(f){let t;return{c(){t=k("canvas"),this.h()},l(n){t=T(n,"CANVAS",{slot:!0,class:!0}),P(t).forEach(c),this.h()},h(){U(t,"slot","canvas"),U(t,"class","svelte-1wvpccn")},m(n,s){M(n,t,s),f[12](t)},p:we,d(n){n&&c(t),f[12](null)}}}function Be(f){let t,n,s,h,o,v,u,m,z,_,b,S,E,R,w,a,C,j,N,D,W,Z,F,ee,V,r,d,e,i,$;function I(l){f[9](l)}let G={id:"pixel-sorting-samples",min:Ce,max:Ne,onChange:null};f[2]!==void 0&&(G.value=f[2]),m=new ye({props:G}),re.push(()=>pe(m,"value",I,f[2]));function x(l){f[11](l)}let te={id:"pixel-sorting-images",onChange:f[10]};return f[4]!==void 0&&(te.value=f[4]),S=new De({props:te}),re.push(()=>pe(S,"value",x,f[4])),{c(){t=k("fieldset"),n=k("div"),s=k("label"),h=B("Samples: ("),o=B(f[2]),v=B(")"),u=O(),H(m.$$.fragment),_=O(),b=k("div"),H(S.$$.fragment),R=O(),w=k("div"),a=k("div"),C=k("button"),j=B("Start"),N=O(),D=k("div"),W=k("button"),Z=B("Pause"),ee=O(),V=k("div"),r=k("button"),d=B("Reset"),this.h()},l(l){t=T(l,"FIELDSET",{slot:!0});var g=P(t);n=T(g,"DIV",{class:!0});var y=P(n);s=T(y,"LABEL",{for:!0});var A=P(s);h=L(A,"Samples: ("),o=L(A,f[2]),v=L(A,")"),A.forEach(c),u=q(y),K(m.$$.fragment,y),y.forEach(c),_=q(g),b=T(g,"DIV",{class:!0});var ie=P(b);K(S.$$.fragment,ie),ie.forEach(c),R=q(g),w=T(g,"DIV",{class:!0});var ne=P(w);a=T(ne,"DIV",{class:!0});var le=P(a);C=T(le,"BUTTON",{});var ae=P(C);j=L(ae,"Start"),ae.forEach(c),le.forEach(c),N=q(ne),D=T(ne,"DIV",{class:!0});var fe=P(D);W=T(fe,"BUTTON",{});var ue=P(W);Z=L(ue,"Pause"),ue.forEach(c),fe.forEach(c),ee=q(ne),V=T(ne,"DIV",{class:!0});var ce=P(V);r=T(ce,"BUTTON",{});var me=P(r);d=L(me,"Reset"),me.forEach(c),ce.forEach(c),ne.forEach(c),g.forEach(c),this.h()},h(){U(s,"for","pixel-sorting-samples"),U(n,"class","demo-input-group"),U(b,"class","demo-input-group"),C.disabled=f[3],U(a,"class","demo-input-group"),W.disabled=F=!f[3],U(D,"class","demo-input-group"),U(V,"class","demo-input-group"),U(w,"class","demo-multi-input-group svelte-1wvpccn"),U(t,"slot","controls")},m(l,g){M(l,t,g),p(t,n),p(n,s),p(s,h),p(s,o),p(s,v),p(n,u),J(m,n,null),p(t,_),p(t,b),J(S,b,null),p(t,R),p(t,w),p(w,a),p(a,C),p(C,j),p(w,N),p(w,D),p(D,W),p(W,Z),p(w,ee),p(w,V),p(V,r),p(r,d),e=!0,i||($=[se(C,"click",f[6]),se(W,"click",f[7]),se(r,"click",f[5])],i=!0)},p(l,g){(!e||g&4)&&Ie(o,l[2]);const y={};!z&&g&4&&(z=!0,y.value=l[2],de(()=>z=!1)),m.$set(y);const A={};g&18&&(A.onChange=l[10]),!E&&g&16&&(E=!0,A.value=l[4],de(()=>E=!1)),S.$set(A),(!e||g&8)&&(C.disabled=l[3]),(!e||g&8&&F!==(F=!l[3]))&&(W.disabled=F)},i(l){e||(Y(m.$$.fragment,l),Y(S.$$.fragment,l),e=!0)},o(l){Q(m.$$.fragment,l),Q(S.$$.fragment,l),e=!1},d(l){l&&c(t),X(m),X(S),i=!1,xe($)}}}function Le(f){let t,n;return t=new Pe({props:{caption:"Pixel Sorting",id:"pixel-sorting-demo",$$slots:{controls:[Be],canvas:[Me]},$$scope:{ctx:f}}}),{c(){H(t.$$.fragment)},l(s){K(t.$$.fragment,s)},m(s,h){J(t,s,h),n=!0},p(s,[h]){const o={};h&8388639&&(o.$$scope={dirty:h,ctx:s}),t.$set(o)},i(s){n||(Y(t.$$.fragment,s),n=!0)},o(s){Q(t.$$.fragment,s),n=!1},d(s){X(t,s)}}}const Ce=1,Ne=100;function We(f,t,n,s,h,o){const v=t-f,u=s-n,m=o-h;return Math.sqrt(v*v+u*u+m*m)}function Re(f,t,n){let s=0,h,o,v,u=0,m=0,z=0,_,b=0,S=50,E=!1,R="/images/starrynight.webp",w=null,a=null;be(()=>{v=o.getContext("2d"),h=document.getElementById("pixel-sorting-demo"),s=Math.floor(window.innerWidth);function r(){const e=Math.floor(window.innerWidth);e!==s&&(s=e,d())}function d(){n(3,E=!1);const e=h.clientWidth,i=window.innerHeight-window.innerHeight/4;if(u=_.width,m=_.height,e>0&&i>0){if(u>e){const $=e/u;u*=$,m*=$}if(m>i){const $=i/m;u*=$,m*=$}u=Math.floor(u),m=Math.floor(m)}n(0,o.width=u,o),n(0,o.height=m,o),n(0,o.style.width=`${u}px`,o),n(0,o.style.height=`${m}px`,o),C()}return n(1,_=new Image),n(1,_.crossOrigin="anonymous",_),n(1,_.onload=d,_),n(1,_.src=R,_),window.addEventListener("resize",r,{passive:!0}),()=>{window.removeEventListener("resize",r)}});function C(){if(n(3,E=!1),window.cancelAnimationFrame(z),u===0||m===0)return;v.clearRect(0,0,u,m),v.drawImage(_,0,0,_.width,_.height,0,0,u,m),b=0,w=v.getImageData(0,0,u,m),a=new Array(u*m*4);const r=w.data;for(let d=0;d<r.length;d+=4){const[e,i,$]=W(r[d],r[d+1],r[d+2]);a[d]=e,a[d+1]=i,a[d+2]=$,a[d+3]=-1}}function j(){b*u*4===w.data.length&&C(),n(3,E=!0),D()}function N(){n(3,E=!1)}function D(){const r=w.data,d=b*u*4;if(d===w.data.length){n(3,E=!1);return}E&&(z=window.requestAnimationFrame(D));for(let e=d;e<d+u*4;e+=4){const i=[],$=Math.floor(e/4%u);if($>0){if(b>0){const g=e-u*4-4;r[g+3]>0&&i.push(a[g],a[g+1],a[g+2])}const l=e-4;r[l+3]>0&&i.push(a[l],a[l+1],a[l+2])}if(b>0){const l=e-u*4;r[l+3]>0&&i.push(a[l],a[l+1],a[l+2])}const I=[],G=new Array(S);for(let l=0;l<S;l++){const g=he($,u),A=(he(b,m)*u+g)*4;I.push(a[A],a[A+1],a[A+2]),G[l]=A}let x=-1,te=Number.POSITIVE_INFINITY;for(let l=0;l<I.length;l+=3){let g=0;for(let y=0;y<i.length;y+=3)g+=We(I[l],i[y],I[l+1],i[y+1],I[l+2],i[y+2]);g/=i.length/3,g<te&&(x=G[l/3],te=g)}if(x>-1){let l=r[e],g=r[e+1],y=r[e+2];r[e]=r[x],r[e+1]=r[x+1],r[e+2]=r[x+2],r[x]=l,r[x+1]=g,r[x+2]=y,l=a[e],g=a[e+1],y=a[e+2],a[e]=a[x],a[e+1]=a[x+1],a[e+2]=a[x+2],a[x]=l,a[x+1]=g,a[x+2]=y}}v.putImageData(w,0,0),b++}function W(r,d,e){r=oe(r/255),d=oe(d/255),e=oe(e/255);let i=.4122214708*r+.5363325363*d+.0514459929*e,$=.2119034982*r+.6806995451*d+.1073969566*e,I=.0883024619*r+.2817188376*d+.6299787005*e;return i=Math.cbrt(i),$=Math.cbrt($),I=Math.cbrt(I),[.2104542553*i+.793617785*$-.0040720468*I,1.9779984951*i-2.428592205*$+.4505937099*I,.0259040371*i+.7827717662*$-.808675766*I]}function Z(r){S=r,n(2,S)}const F=()=>{n(1,_.src=R,_),D()};function ee(r){R=r,n(4,R)}function V(r){re[r?"unshift":"push"](()=>{o=r,n(0,o)})}return[o,_,S,E,R,C,j,N,D,Z,F,ee,V]}class Ve extends $e{constructor(t){super(),_e(this,t,Re,Le,ve,{})}}function Ae(f){let t;return{c(){t=B("Pixel Sorting")},l(n){t=L(n,"Pixel Sorting")},m(n,s){M(n,t,s)},d(n){n&&c(t)}}}function Oe(f){let t;return{c(){t=B("Kjetil Golid")},l(n){t=L(n,"Kjetil Golid")},m(n,s){M(n,t,s)},d(n){n&&c(t)}}}function qe(f){let t;return{c(){t=B("Oklab")},l(n){t=L(n,"Oklab")},m(n,s){M(n,t,s)},d(n){n&&c(t)}}}function Fe(f){let t,n,s,h,o,v,u,m,z,_,b,S,E,R,w,a,C,j,N,D,W,Z,F,ee,V,r,d;return t=new ke({props:{timestamp:1651809600,$$slots:{default:[Ae]},$$scope:{ctx:f}}}),o=new ge({props:{href:"https://twitter.com/kGolid",$$slots:{default:[Oe]},$$scope:{ctx:f}}}),E=new ge({props:{href:"https://bottosson.github.io/posts/oklab/",$$slots:{default:[qe]},$$scope:{ctx:f}}}),r=new Ve({}),{c(){H(t.$$.fragment),n=O(),s=k("p"),h=B("Implementing "),H(o.$$.fragment),v=B(" pixel/color sorting."),u=O(),m=k("p"),z=B(`For every pixel in the image, compute the average color of the
			current pixel's surrounding pixels. Within a maximum number of
			tries, find a different non-processed pixel with the most similar
			color to the computed average and swap them.`),_=O(),b=k("p"),S=B(`sRGB is not the best color space for a color difference function. I
			converted the colors to `),H(E.$$.fragment),R=B("."),w=O(),a=k("p"),C=B("The orientation and result of this effect is a combination of:"),j=O(),N=k("ul"),D=k("li"),W=B(`The algorithm processes pixels from top to bottom. This is not a
				requirement. I've seen vastly cooler versions, such as a radial
				one and a seemingly noise-based one.`),Z=O(),F=k("li"),ee=B(`Which and how many of the 8 surrounding pixels are being used to
				compute the color difference. In this demo, I'm using the
				top-left, top, and left pixels.`),V=O(),H(r.$$.fragment)},l(e){K(t.$$.fragment,e),n=q(e),s=T(e,"P",{});var i=P(s);h=L(i,"Implementing "),K(o.$$.fragment,i),v=L(i," pixel/color sorting."),i.forEach(c),u=q(e),m=T(e,"P",{});var $=P(m);z=L($,`For every pixel in the image, compute the average color of the
			current pixel's surrounding pixels. Within a maximum number of
			tries, find a different non-processed pixel with the most similar
			color to the computed average and swap them.`),$.forEach(c),_=q(e),b=T(e,"P",{});var I=P(b);S=L(I,`sRGB is not the best color space for a color difference function. I
			converted the colors to `),K(E.$$.fragment,I),R=L(I,"."),I.forEach(c),w=q(e),a=T(e,"P",{});var G=P(a);C=L(G,"The orientation and result of this effect is a combination of:"),G.forEach(c),j=q(e),N=T(e,"UL",{});var x=P(N);D=T(x,"LI",{});var te=P(D);W=L(te,`The algorithm processes pixels from top to bottom. This is not a
				requirement. I've seen vastly cooler versions, such as a radial
				one and a seemingly noise-based one.`),te.forEach(c),Z=q(x),F=T(x,"LI",{});var l=P(F);ee=L(l,`Which and how many of the 8 surrounding pixels are being used to
				compute the color difference. In this demo, I'm using the
				top-left, top, and left pixels.`),l.forEach(c),x.forEach(c),V=q(e),K(r.$$.fragment,e)},m(e,i){J(t,e,i),M(e,n,i),M(e,s,i),p(s,h),J(o,s,null),p(s,v),M(e,u,i),M(e,m,i),p(m,z),M(e,_,i),M(e,b,i),p(b,S),J(E,b,null),p(b,R),M(e,w,i),M(e,a,i),p(a,C),M(e,j,i),M(e,N,i),p(N,D),p(D,W),p(N,Z),p(N,F),p(F,ee),M(e,V,i),J(r,e,i),d=!0},p(e,i){const $={};i&1&&($.$$scope={dirty:i,ctx:e}),t.$set($);const I={};i&1&&(I.$$scope={dirty:i,ctx:e}),o.$set(I);const G={};i&1&&(G.$$scope={dirty:i,ctx:e}),E.$set(G)},i(e){d||(Y(t.$$.fragment,e),Y(o.$$.fragment,e),Y(E.$$.fragment,e),Y(r.$$.fragment,e),d=!0)},o(e){Q(t.$$.fragment,e),Q(o.$$.fragment,e),Q(E.$$.fragment,e),Q(r.$$.fragment,e),d=!1},d(e){X(t,e),e&&c(n),e&&c(s),X(o),e&&c(u),e&&c(m),e&&c(_),e&&c(b),X(E),e&&c(w),e&&c(a),e&&c(j),e&&c(N),e&&c(V),X(r,e)}}}function Ge(f){let t,n;return t=new Se({props:{$$slots:{default:[Fe]},$$scope:{ctx:f}}}),{c(){H(t.$$.fragment)},l(s){K(t.$$.fragment,s)},m(s,h){J(t,s,h),n=!0},p(s,h){const o={};h&1&&(o.$$scope={dirty:h,ctx:s}),t.$set(o)},i(s){n||(Y(t.$$.fragment,s),n=!0)},o(s){Q(t.$$.fragment,s),n=!1},d(s){X(t,s)}}}function ze(f){let t,n,s,h;return t=new Te({props:{title:"Pixel Sorting",description:"Sort image colors by similarity",keywords:"Pixel Sorting, Color Sorting, Javascript"}}),s=new Ee({props:{$$slots:{default:[Ge]},$$scope:{ctx:f}}}),{c(){H(t.$$.fragment),n=O(),H(s.$$.fragment)},l(o){K(t.$$.fragment,o),n=q(o),K(s.$$.fragment,o)},m(o,v){J(t,o,v),M(o,n,v),J(s,o,v),h=!0},p(o,[v]){const u={};v&1&&(u.$$scope={dirty:v,ctx:o}),s.$set(u)},i(o){h||(Y(t.$$.fragment,o),Y(s.$$.fragment,o),h=!0)},o(o){Q(t.$$.fragment,o),Q(s.$$.fragment,o),h=!1},d(o){X(t,o),o&&c(n),X(s,o)}}}class Ze extends $e{constructor(t){super(),_e(this,t,null,ze,ve,{})}}export{Ze as default};
