import{S as ne,i as se,s as ae,w as W,x as N,y as A,f as B,t as P,z as V,o as fe,k,l as q,m as M,h as b,n as G,b as T,B as he,J as X,K as Z,q as L,a as H,r as Q,c as K,G as E,u as me,M as U}from"../../../chunks/index-6be07ad6.js";import{M as ge,S as pe,T as de}from"../../../chunks/Main-d501f058.js";/* empty css                                                             */import{S as $e}from"../../../chunks/Seo-8afd16e9.js";import{D as _e}from"../../../chunks/DemoContainer-02f198f6.js";import{I as we}from"../../../chunks/ImageSelect-24d6df7c.js";import{N as ve}from"../../../chunks/NumberRange-767509e5.js";import{d as be}from"../../../chunks/core-ddcb889b.js";function ze(l){let e;return{c(){e=k("canvas"),this.h()},l(n){e=q(n,"CANVAS",{slot:!0,class:!0}),M(e).forEach(b),this.h()},h(){G(e,"slot","canvas"),G(e,"class","svelte-10p45u9")},m(n,s){T(n,e,s),l[9](e)},p:he,d(n){n&&b(e),l[9](null)}}}function Ie(l){let e,n,s,u,o,p,m,$,_,w,c,d,I,a;function g(h){l[6](h)}let z={id:"colors",min:Ee,max:ye,step:1,onChange:l[5]};l[2]!==void 0&&(z.value=l[2]),$=new ve({props:z}),X.push(()=>Z($,"value",g,l[2]));function D(h){l[8](h)}let R={id:"image-select",onChange:l[7]};return l[3]!==void 0&&(R.value=l[3]),d=new we({props:R}),X.push(()=>Z(d,"value",D,l[3])),{c(){e=k("fieldset"),n=k("div"),s=k("label"),u=L("Colors: ("),o=L(l[2]),p=L(")"),m=H(),W($.$$.fragment),w=H(),c=k("div"),W(d.$$.fragment),this.h()},l(h){e=q(h,"FIELDSET",{slot:!0});var C=M(e);n=q(C,"DIV",{class:!0});var S=M(n);s=q(S,"LABEL",{for:!0});var O=M(s);u=Q(O,"Colors: ("),o=Q(O,l[2]),p=Q(O,")"),O.forEach(b),m=K(S),N($.$$.fragment,S),S.forEach(b),w=K(C),c=q(C,"DIV",{class:!0});var j=M(c);N(d.$$.fragment,j),j.forEach(b),C.forEach(b),this.h()},h(){G(s,"for","colors"),G(n,"class","demo-input-group"),G(c,"class","demo-input-group"),G(e,"slot","controls")},m(h,C){T(h,e,C),E(e,n),E(n,s),E(s,u),E(s,o),E(s,p),E(n,m),A($,n,null),E(e,w),E(e,c),A(d,c,null),a=!0},p(h,C){(!a||C&4)&&me(o,h[2]);const S={};!_&&C&4&&(_=!0,S.value=h[2],U(()=>_=!1)),$.$set(S);const O={};C&10&&(O.onChange=h[7]),!I&&C&8&&(I=!0,O.value=h[3],U(()=>I=!1)),d.$set(O)},i(h){a||(B($.$$.fragment,h),B(d.$$.fragment,h),a=!0)},o(h){P($.$$.fragment,h),P(d.$$.fragment,h),a=!1},d(h){h&&b(e),V($),V(d)}}}function Ce(l){let e,n;return e=new _e({props:{caption:"Octree Color Quantization",id:"octree-color-quantization-demo",$$slots:{controls:[Ie],canvas:[ze]},$$scope:{ctx:l}}}),{c(){W(e.$$.fragment)},l(s){N(e.$$.fragment,s)},m(s,u){A(e,s,u),n=!0},p(s,[u]){const o={};u&33554447&&(o.$$scope={dirty:u,ctx:s}),e.$set(o)},i(s){n||(B(e.$$.fragment,s),n=!0)},o(s){P(e.$$.fragment,s),n=!1},d(s){V(e,s)}}}const Ee=1,ye=255,ee=256,Oe=8;function te(l,e,n){return l+","+e+","+n}function Se(l,e,n){class s{constructor(r,t,i=Number.POSITIVE_INFINITY){this.node=new u(r,t),this.depth=i}insert(r,t=this.node){if(t.children===null)if(t.data){if(t.data[0]===r[0]&&t.data[1]===r[1]&&t.data[2]===r[2]||this.getDepth(t)>=this.depth)return;const x=[...t.data];t.data=null,t.divide();const Y=this.getIndex(t.center,x);t.children[Y].data=x,this.insert(r,t)}else t.data=r;else{const v=this.getIndex(t.center,r);this.insert(r,t.children[v])}}getIndex(r,t){let i=0;return i|=r[1]>t[1]?0:4,i|=r[0]>t[0]?0:2,i|=r[2]>t[2]?0:1,i}getDepth(r){let t=r.size,i=0;for(;this.node.size>t;)t*=2,i++;return i}dfs(r,t=this.node){const i=v=>{r(v),v.children&&v.children.forEach(x=>i(x))};i(t)}}class u{constructor(r,t){this.center=r,this.size=t,this.children=null,this.data=null}divide(){this.children=new Array(8);for(let r=0;r<this.children.length;r++){const t=[...this.center],i=this.size*.25;(r&4)===4?t[1]+=i:t[1]-=i,(r&2)===2?t[0]+=i:t[0]-=i,(r&1)===1?t[2]+=i:t[2]-=i,this.children[r]=new u(t,this.size*.5)}}}let o=0,p,m,$,_=0,w=0,c,d=8,I="/images/starrynight.webp",a,g,z=[];const D=ee/2;let R;fe(()=>{$=m.getContext("2d"),p=document.getElementById("octree-color-quantization-demo"),o=Math.floor(window.innerWidth);function f(){const t=Math.floor(window.innerWidth);t!==o&&(o=t,r())}function r(){const t=p.clientWidth,i=window.innerHeight-window.innerHeight/4;if(_=c.width,w=c.height,t>0&&i>0){if(_>t){const v=t/_;_*=v,w*=v}if(w>i){const v=i/w;_*=v,w*=v}_=Math.floor(_),w=Math.floor(w)}n(0,m.width=_,m),n(0,m.height=w,m),n(0,m.style.width=`${_}px`,m),n(0,m.style.height=`${w}px`,m),h()}return n(1,c=new Image),n(1,c.crossOrigin="anonymous",c),n(1,c.onload=r,c),n(1,c.src=I,c),window.addEventListener("resize",f,{passive:!0}),()=>{window.removeEventListener("resize",f)}});function h(){if(R=new s([D,D,D],ee,Oe),!(_===0||w===0)){$.drawImage(c,0,0,c.width,c.height,0,0,_,w),a=$.getImageData(0,0,_,w),g=[...a.data];for(let f=0;f<a.data.length;f+=4)R.insert([g[f],g[f+1],g[f+2]]);z=[],O(),C()}}function C(){const f=j(d),r=a.data;for(let t=0;t<r.length;t+=4){const i=te(g[t],g[t+1],g[t+2]),v=f[i];r[t]=v[0],r[t+1]=v[1],r[t+2]=v[2]}$.putImageData(a,0,0)}const S=be(C,100);function O(){R.dfs(f=>{const r=[];R.dfs(t=>{t.data!==null&&r.push(t.data[0],t.data[1],t.data[2])},f),z.push(r)}),z.sort((f,r)=>f.length>r.length?-1:r.length>f.length?1:0)}function j(f){const r={};for(let t=0;t<f;t++){const i=z[t];let v=[],x=0,Y=0,F=0;for(let y=0;y<i.length;y+=3){const ue=te(i[y],i[y+1],i[y+2]);v.push(ue),x+=i[y],Y+=i[y+1],F+=i[y+2]}const J=i.length/3;x/=J,Y/=J,F/=J;const ce=[x,Y,F];for(let y=0;y<v.length;y++)r[v[y]]=ce}return r}function re(f){d=f,n(2,d)}const oe=()=>{n(1,c.src=I,c),h()};function ie(f){I=f,n(3,I)}function le(f){X[f?"unshift":"push"](()=>{m=f,n(0,m)})}return[m,c,d,I,h,S,re,oe,ie,le]}class Te extends ne{constructor(e){super(),se(this,e,Se,Ce,ae,{})}}function De(l){let e;return{c(){e=L("Octree Color Quantization")},l(n){e=Q(n,"Octree Color Quantization")},m(n,s){T(n,e,s)},d(n){n&&b(e)}}}function xe(l){let e,n,s,u,o,p,m,$,_,w,c,d,I;return e=new de({props:{timestamp:1652328e3,$$slots:{default:[De]},$$scope:{ctx:l}}}),d=new Te({}),{c(){W(e.$$.fragment),n=H(),s=k("p"),u=L(`To get an idea of how this work. Imagine an Octree as an XYZ axes
			plot. We can insert an RGB color by using each channel as a
			position. The r channel is the x coordinate, g is y and b is z.`),o=H(),p=k("p"),m=L(`Then you have to pick the smallest possible sub-cube that contains
			the number of colors specified in the `),$=k("var"),_=L("quantization"),w=L(" function."),c=H(),W(d.$$.fragment)},l(a){N(e.$$.fragment,a),n=K(a),s=q(a,"P",{});var g=M(s);u=Q(g,`To get an idea of how this work. Imagine an Octree as an XYZ axes
			plot. We can insert an RGB color by using each channel as a
			position. The r channel is the x coordinate, g is y and b is z.`),g.forEach(b),o=K(a),p=q(a,"P",{});var z=M(p);m=Q(z,`Then you have to pick the smallest possible sub-cube that contains
			the number of colors specified in the `),$=q(z,"VAR",{});var D=M($);_=Q(D,"quantization"),D.forEach(b),w=Q(z," function."),z.forEach(b),c=K(a),N(d.$$.fragment,a)},m(a,g){A(e,a,g),T(a,n,g),T(a,s,g),E(s,u),T(a,o,g),T(a,p,g),E(p,m),E(p,$),E($,_),E(p,w),T(a,c,g),A(d,a,g),I=!0},p(a,g){const z={};g&1&&(z.$$scope={dirty:g,ctx:a}),e.$set(z)},i(a){I||(B(e.$$.fragment,a),B(d.$$.fragment,a),I=!0)},o(a){P(e.$$.fragment,a),P(d.$$.fragment,a),I=!1},d(a){V(e,a),a&&b(n),a&&b(s),a&&b(o),a&&b(p),a&&b(c),V(d,a)}}}function ke(l){let e,n;return e=new pe({props:{$$slots:{default:[xe]},$$scope:{ctx:l}}}),{c(){W(e.$$.fragment)},l(s){N(e.$$.fragment,s)},m(s,u){A(e,s,u),n=!0},p(s,u){const o={};u&1&&(o.$$scope={dirty:u,ctx:s}),e.$set(o)},i(s){n||(B(e.$$.fragment,s),n=!0)},o(s){P(e.$$.fragment,s),n=!1},d(s){V(e,s)}}}function qe(l){let e,n,s,u;return e=new $e({props:{title:"Octree Color Quantization",description:"Using an octree to color quantize an image",keywords:"Octree, Javascript, Image Processing, Quantization, Canvas2D"}}),s=new ge({props:{$$slots:{default:[ke]},$$scope:{ctx:l}}}),{c(){W(e.$$.fragment),n=H(),W(s.$$.fragment)},l(o){N(e.$$.fragment,o),n=K(o),N(s.$$.fragment,o)},m(o,p){A(e,o,p),T(o,n,p),A(s,o,p),u=!0},p(o,[p]){const m={};p&1&&(m.$$scope={dirty:p,ctx:o}),s.$set(m)},i(o){u||(B(e.$$.fragment,o),B(s.$$.fragment,o),u=!0)},o(o){P(e.$$.fragment,o),P(s.$$.fragment,o),u=!1},d(o){V(e,o),o&&b(n),V(s,o)}}}class Ve extends ne{constructor(e){super(),se(this,e,null,qe,ae,{})}}export{Ve as default};
