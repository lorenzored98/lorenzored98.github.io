import{S as se,i as ae,s as re,w as O,x as T,y as k,f as x,t as q,z as y,o as me,k as W,l as N,m as P,h as _,n as H,b as D,B as he,J as X,K as Z,q as A,a as B,r as L,c as V,G as E,u as $e,M as U}from"../../../chunks/index-94ae1f6d.js";import{M as pe,F as ge,S as ee,T as de,a as _e}from"../../../chunks/Footer-1dc26ee9.js";import{S as we}from"../../../chunks/Seo-fd8654ed.js";import{D as be}from"../../../chunks/DemoContainer-4346ca13.js";import{I as ve}from"../../../chunks/ImageSelect-d00fa4b4.js";import{N as ze}from"../../../chunks/NumberRange-fce9b211.js";import{d as Ie}from"../../../chunks/core-2382e8f7.js";function Ce(u){let e;return{c(){e=W("canvas"),this.h()},l(t){e=N(t,"CANVAS",{slot:!0,class:!0}),P(e).forEach(_),this.h()},h(){H(e,"slot","canvas"),H(e,"class","svelte-10p45u9")},m(t,a){D(t,e,a),u[9](e)},p:he,d(t){t&&_(e),u[9](null)}}}function Ee(u){let e,t,a,m,r,o,n,c,g,b,h,w,I,i;function d(p){u[6](p)}let z={id:"colors",min:Se,max:Oe,step:1,onChange:u[5]};u[2]!==void 0&&(z.value=u[2]),c=new ze({props:z}),X.push(()=>Z(c,"value",d));function F(p){u[8](p)}let G={id:"image-select",onChange:u[7]};return u[3]!==void 0&&(G.value=u[3]),w=new ve({props:G}),X.push(()=>Z(w,"value",F)),{c(){e=W("fieldset"),t=W("div"),a=W("label"),m=A("Colors: ("),r=A(u[2]),o=A(")"),n=B(),O(c.$$.fragment),b=B(),h=W("div"),O(w.$$.fragment),this.h()},l(p){e=N(p,"FIELDSET",{slot:!0});var C=P(e);t=N(C,"DIV",{class:!0});var Q=P(t);a=N(Q,"LABEL",{for:!0});var M=P(a);m=L(M,"Colors: ("),r=L(M,u[2]),o=L(M,")"),M.forEach(_),n=V(Q),T(c.$$.fragment,Q),Q.forEach(_),b=V(C),h=N(C,"DIV",{class:!0});var Y=P(h);T(w.$$.fragment,Y),Y.forEach(_),C.forEach(_),this.h()},h(){H(a,"for","colors"),H(t,"class","demo-input-group"),H(h,"class","demo-input-group"),H(e,"slot","controls")},m(p,C){D(p,e,C),E(e,t),E(t,a),E(a,m),E(a,r),E(a,o),E(t,n),k(c,t,null),E(e,b),E(e,h),k(w,h,null),i=!0},p(p,C){(!i||C&4)&&$e(r,p[2]);const Q={};!g&&C&4&&(g=!0,Q.value=p[2],U(()=>g=!1)),c.$set(Q);const M={};C&10&&(M.onChange=p[7]),!I&&C&8&&(I=!0,M.value=p[3],U(()=>I=!1)),w.$set(M)},i(p){i||(x(c.$$.fragment,p),x(w.$$.fragment,p),i=!0)},o(p){q(c.$$.fragment,p),q(w.$$.fragment,p),i=!1},d(p){p&&_(e),y(c),y(w)}}}function De(u){let e,t;return e=new be({props:{caption:"Octree Color Quantization",id:"octree-color-quantization-demo",$$slots:{controls:[Ee],canvas:[Ce]},$$scope:{ctx:u}}}),{c(){O(e.$$.fragment)},l(a){T(e.$$.fragment,a)},m(a,m){k(e,a,m),t=!0},p(a,[m]){const r={};m&33554447&&(r.$$scope={dirty:m,ctx:a}),e.$set(r)},i(a){t||(x(e.$$.fragment,a),t=!0)},o(a){q(e.$$.fragment,a),t=!1},d(a){y(e,a)}}}const Se=1,Oe=255,te=256,Te=8;function ne(u,e,t){return u+","+e+","+t}function ke(u,e,t){class a{constructor(l,s,f=Number.POSITIVE_INFINITY){this.node=new m(l,s),this.depth=f}insert(l,s=this.node){if(s.children===null)if(s.data){if(s.data[0]===l[0]&&s.data[1]===l[1]&&s.data[2]===l[2]||this.getDepth(s)>=this.depth)return;const R=[...s.data];s.data=null,s.divide();const K=this.getIndex(s.center,R);s.children[K].data=R,this.insert(l,s)}else s.data=l;else{const v=this.getIndex(s.center,l);this.insert(l,s.children[v])}}getIndex(l,s){let f=0;return f|=l[1]>s[1]?0:4,f|=l[0]>s[0]?0:2,f|=l[2]>s[2]?0:1,f}getDepth(l){let s=l.size,f=0;for(;this.node.size>s;)s*=2,f++;return f}dfs(l,s=this.node){const f=v=>{l(v),v.children&&v.children.forEach(R=>f(R))};f(s)}}class m{constructor(l,s){this.center=l,this.size=s,this.children=null,this.data=null}divide(){this.children=new Array(8);for(let l=0;l<this.children.length;l++){const s=[...this.center],f=this.size*.25;(l&4)===4?s[1]+=f:s[1]-=f,(l&2)===2?s[0]+=f:s[0]-=f,(l&1)===1?s[2]+=f:s[2]-=f,this.children[l]=new m(s,this.size*.5)}}}let r=0,o,n,c,g=0,b=0,h,w=8,I="/images/starrynight.webp",i,d,z=[];const F=te/2;let G;me(()=>{c=n.getContext("2d"),o=document.getElementById("octree-color-quantization-demo"),r=Math.floor(window.innerWidth);function $(){const s=Math.floor(window.innerWidth);s!==r&&(r=s,l())}function l(){const s=o.clientWidth,f=window.innerHeight-window.innerHeight/4;if(g=h.width,b=h.height,s>0&&f>0){if(g>s){const v=s/g;g*=v,b*=v}if(b>f){const v=f/b;g*=v,b*=v}g=Math.floor(g),b=Math.floor(b)}t(0,n.width=g,n),t(0,n.height=b,n),t(0,n.style.width=`${g}px`,n),t(0,n.style.height=`${b}px`,n),p()}return t(1,h=new Image),t(1,h.crossOrigin="anonymous",h),t(1,h.onload=l,h),t(1,h.src=I,h),window.addEventListener("resize",$,{passive:!0}),()=>{window.removeEventListener("resize",$)}});function p(){if(G=new a([F,F,F],te,Te),!(g===0||b===0)){c.drawImage(h,0,0,h.width,h.height,0,0,g,b),i=c.getImageData(0,0,g,b),d=[...i.data];for(let $=0;$<i.data.length;$+=4)G.insert([d[$],d[$+1],d[$+2]]);z=[],M(),C()}}function C(){const $=Y(w),l=i.data;for(let s=0;s<l.length;s+=4){const f=ne(d[s],d[s+1],d[s+2]),v=$[f];l[s]=v[0],l[s+1]=v[1],l[s+2]=v[2]}c.putImageData(i,0,0)}const Q=Ie(C,100);function M(){G.dfs($=>{const l=[];G.dfs(s=>{s.data!==null&&l.push(s.data[0],s.data[1],s.data[2])},$),z.push(l)}),z.sort(($,l)=>$.length>l.length?-1:l.length>$.length?1:0)}function Y($){const l={};for(let s=0;s<$;s++){const f=z[s];let v=[],R=0,K=0,j=0;for(let S=0;S<f.length;S+=3){const ue=ne(f[S],f[S+1],f[S+2]);v.push(ue),R+=f[S],K+=f[S+1],j+=f[S+2]}const J=f.length/3;R/=J,K/=J,j/=J;const fe=[R,K,j];for(let S=0;S<v.length;S++)l[v[S]]=fe}return l}function oe($){w=$,t(2,w)}const ie=()=>{t(1,h.src=I,h),p()};function le($){I=$,t(3,I)}function ce($){X[$?"unshift":"push"](()=>{n=$,t(0,n)})}return[n,h,w,I,p,Q,oe,ie,le,ce]}class xe extends se{constructor(e){super(),ae(this,e,ke,De,re,{})}}function qe(u){let e;return{c(){e=A("Octree Color Quantization")},l(t){e=L(t,"Octree Color Quantization")},m(t,a){D(t,e,a)},d(t){t&&_(e)}}}function ye(u){let e,t,a,m,r;return e=new de({props:{timestamp:1652328e3,$$slots:{default:[qe]},$$scope:{ctx:u}}}),{c(){O(e.$$.fragment),t=B(),a=W("p"),m=A("A color matrioska.")},l(o){T(e.$$.fragment,o),t=V(o),a=N(o,"P",{});var n=P(a);m=L(n,"A color matrioska."),n.forEach(_)},m(o,n){k(e,o,n),D(o,t,n),D(o,a,n),E(a,m),r=!0},p(o,n){const c={};n&1&&(c.$$scope={dirty:n,ctx:o}),e.$set(c)},i(o){r||(x(e.$$.fragment,o),r=!0)},o(o){q(e.$$.fragment,o),r=!1},d(o){y(e,o),o&&_(t),o&&_(a)}}}function Me(u){let e;return{c(){e=A("Demo")},l(t){e=L(t,"Demo")},m(t,a){D(t,e,a)},d(t){t&&_(e)}}}function Ae(u){let e,t,a,m,r,o,n,c,g,b,h,w,I;return e=new _e({props:{id:"demo",$$slots:{default:[Me]},$$scope:{ctx:u}}}),w=new xe({}),{c(){O(e.$$.fragment),t=B(),a=W("p"),m=A(`To get an idea of how this work. Imagine an Octree as an XYZ axes
			plot. We can insert an RGB color by using each channel as a
			position. The r channel is the x coordinate, g is y and b is z.`),r=B(),o=W("p"),n=A(`Then you have to pick the smallest possible sub-cube that contains
			the number of colors specified in the `),c=W("var"),g=A("quantization"),b=A(" function."),h=B(),O(w.$$.fragment)},l(i){T(e.$$.fragment,i),t=V(i),a=N(i,"P",{});var d=P(a);m=L(d,`To get an idea of how this work. Imagine an Octree as an XYZ axes
			plot. We can insert an RGB color by using each channel as a
			position. The r channel is the x coordinate, g is y and b is z.`),d.forEach(_),r=V(i),o=N(i,"P",{});var z=P(o);n=L(z,`Then you have to pick the smallest possible sub-cube that contains
			the number of colors specified in the `),c=N(z,"VAR",{});var F=P(c);g=L(F,"quantization"),F.forEach(_),b=L(z," function."),z.forEach(_),h=V(i),T(w.$$.fragment,i)},m(i,d){k(e,i,d),D(i,t,d),D(i,a,d),E(a,m),D(i,r,d),D(i,o,d),E(o,n),E(o,c),E(c,g),E(o,b),D(i,h,d),k(w,i,d),I=!0},p(i,d){const z={};d&1&&(z.$$scope={dirty:d,ctx:i}),e.$set(z)},i(i){I||(x(e.$$.fragment,i),x(w.$$.fragment,i),I=!0)},o(i){q(e.$$.fragment,i),q(w.$$.fragment,i),I=!1},d(i){y(e,i),i&&_(t),i&&_(a),i&&_(r),i&&_(o),i&&_(h),y(w,i)}}}function Le(u){let e,t,a,m;return e=new ee({props:{$$slots:{default:[ye]},$$scope:{ctx:u}}}),a=new ee({props:{$$slots:{default:[Ae]},$$scope:{ctx:u}}}),{c(){O(e.$$.fragment),t=B(),O(a.$$.fragment)},l(r){T(e.$$.fragment,r),t=V(r),T(a.$$.fragment,r)},m(r,o){k(e,r,o),D(r,t,o),k(a,r,o),m=!0},p(r,o){const n={};o&1&&(n.$$scope={dirty:o,ctx:r}),e.$set(n);const c={};o&1&&(c.$$scope={dirty:o,ctx:r}),a.$set(c)},i(r){m||(x(e.$$.fragment,r),x(a.$$.fragment,r),m=!0)},o(r){q(e.$$.fragment,r),q(a.$$.fragment,r),m=!1},d(r){y(e,r),r&&_(t),y(a,r)}}}function Qe(u){let e,t,a,m,r,o;return e=new we({props:{title:"Octree Color Quantization",description:"Using an octree to color quantize an image",keywords:"Octree, Javascript, Image Processing, Quantization, Canvas2D"}}),a=new pe({props:{$$slots:{default:[Le]},$$scope:{ctx:u}}}),r=new ge({}),{c(){O(e.$$.fragment),t=B(),O(a.$$.fragment),m=B(),O(r.$$.fragment)},l(n){T(e.$$.fragment,n),t=V(n),T(a.$$.fragment,n),m=V(n),T(r.$$.fragment,n)},m(n,c){k(e,n,c),D(n,t,c),k(a,n,c),D(n,m,c),k(r,n,c),o=!0},p(n,[c]){const g={};c&1&&(g.$$scope={dirty:c,ctx:n}),a.$set(g)},i(n){o||(x(e.$$.fragment,n),x(a.$$.fragment,n),x(r.$$.fragment,n),o=!0)},o(n){q(e.$$.fragment,n),q(a.$$.fragment,n),q(r.$$.fragment,n),o=!1},d(n){y(e,n),n&&_(t),y(a,n),n&&_(m),y(r,n)}}}class Ge extends se{constructor(e){super(),ae(this,e,null,Qe,re,{})}}export{Ge as default};
