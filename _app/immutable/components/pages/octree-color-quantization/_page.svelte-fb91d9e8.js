import{S as se,i as ae,s as re,w as S,x as O,y as T,f as k,t as y,z as q,o as me,k as W,l as N,m as P,h as _,n as j,b as x,B as he,J as Y,K as X,q as A,a as V,r as L,c as F,G as E,u as $e,M as Z}from"../../../chunks/index-eac81cc4.js";import{M as pe,F as ge,S as ee,T as de,a as _e}from"../../../chunks/Footer-e049357b.js";import{S as we}from"../../../chunks/Seo-593c0eb7.js";import{D as ve}from"../../../chunks/DemoContainer-367e056c.js";import{I as be}from"../../../chunks/ImageSelect-28d0b1be.js";import{N as ze}from"../../../chunks/NumberRange-2f6f0500.js";import{d as Ie}from"../../../chunks/core-2382e8f7.js";function Ce(u){let e;return{c(){e=W("canvas"),this.h()},l(t){e=N(t,"CANVAS",{slot:!0,class:!0}),P(e).forEach(_),this.h()},h(){j(e,"slot","canvas"),j(e,"class","svelte-10p45u9")},m(t,a){x(t,e,a),u[9](e)},p:he,d(t){t&&_(e),u[9](null)}}}function Ee(u){let e,t,a,m,r,o,n,c,g,v,h,w,I,i;function d(p){u[6](p)}let z={id:"colors",min:De,max:Se,step:1,onChange:u[5]};u[2]!==void 0&&(z.value=u[2]),c=new ze({props:z}),Y.push(()=>X(c,"value",d));function B(p){u[8](p)}let K={id:"image-select",onChange:u[7]};return u[3]!==void 0&&(K.value=u[3]),w=new be({props:K}),Y.push(()=>X(w,"value",B)),{c(){e=W("fieldset"),t=W("div"),a=W("label"),m=A("Colors: ("),r=A(u[2]),o=A(")"),n=V(),S(c.$$.fragment),v=V(),h=W("div"),S(w.$$.fragment),this.h()},l(p){e=N(p,"FIELDSET",{slot:!0});var C=P(e);t=N(C,"DIV",{class:!0});var Q=P(t);a=N(Q,"LABEL",{for:!0});var M=P(a);m=L(M,"Colors: ("),r=L(M,u[2]),o=L(M,")"),M.forEach(_),n=F(Q),O(c.$$.fragment,Q),Q.forEach(_),v=F(C),h=N(C,"DIV",{class:!0});var R=P(h);O(w.$$.fragment,R),R.forEach(_),C.forEach(_),this.h()},h(){j(a,"for","colors"),j(t,"class","demo-input-group"),j(h,"class","demo-input-group"),j(e,"slot","controls")},m(p,C){x(p,e,C),E(e,t),E(t,a),E(a,m),E(a,r),E(a,o),E(t,n),T(c,t,null),E(e,v),E(e,h),T(w,h,null),i=!0},p(p,C){(!i||C&4)&&$e(r,p[2]);const Q={};!g&&C&4&&(g=!0,Q.value=p[2],Z(()=>g=!1)),c.$set(Q);const M={};C&10&&(M.onChange=p[7]),!I&&C&8&&(I=!0,M.value=p[3],Z(()=>I=!1)),w.$set(M)},i(p){i||(k(c.$$.fragment,p),k(w.$$.fragment,p),i=!0)},o(p){y(c.$$.fragment,p),y(w.$$.fragment,p),i=!1},d(p){p&&_(e),q(c),q(w)}}}function xe(u){let e,t;return e=new ve({props:{caption:"Octree Color Quantization",id:"octree-color-quantization-demo",$$slots:{controls:[Ee],canvas:[Ce]},$$scope:{ctx:u}}}),{c(){S(e.$$.fragment)},l(a){O(e.$$.fragment,a)},m(a,m){T(e,a,m),t=!0},p(a,[m]){const r={};m&33554447&&(r.$$scope={dirty:m,ctx:a}),e.$set(r)},i(a){t||(k(e.$$.fragment,a),t=!0)},o(a){y(e.$$.fragment,a),t=!1},d(a){q(e,a)}}}const De=1,Se=255,te=256,Oe=8;function ne(u,e,t){return u+","+e+","+t}function Te(u,e,t){class a{constructor(l,s,f=Number.POSITIVE_INFINITY){this.node=new m(l,s),this.depth=f}insert(l,s=this.node){if(s.children===null)if(s.data){if(s.data[0]===l[0]&&s.data[1]===l[1]&&s.data[2]===l[2]||this.getDepth(s)>=this.depth)return;const H=[...s.data];s.data=null,s.divide();const J=this.getIndex(s.center,H);s.children[J].data=H,this.insert(l,s)}else s.data=l;else{const b=this.getIndex(s.center,l);this.insert(l,s.children[b])}}getIndex(l,s){let f=0;return f|=l[1]>s[1]?0:4,f|=l[0]>s[0]?0:2,f|=l[2]>s[2]?0:1,f}getDepth(l){let s=l.size,f=0;for(;this.node.size>s;)s*=2,f++;return f}dfs(l,s=this.node){const f=b=>{l(b),b.children&&b.children.forEach(H=>f(H))};f(s)}}class m{constructor(l,s){this.center=l,this.size=s,this.children=null,this.data=null}divide(){this.children=new Array(8);for(let l=0;l<this.children.length;l++){const s=[...this.center],f=this.size*.25;(l&4)===4?s[1]+=f:s[1]-=f,(l&2)===2?s[0]+=f:s[0]-=f,(l&1)===1?s[2]+=f:s[2]-=f,this.children[l]=new m(s,this.size*.5)}}}let r=0,o,n,c,g=0,v=0,h,w=8,I="/images/starrynight.webp",i,d,z=[];const B=te/2;let K;me(()=>{c=n.getContext("2d"),o=document.getElementById("octree-color-quantization-demo"),r=Math.floor(window.innerWidth);function $(){const s=Math.floor(window.innerWidth);s!==r&&(r=s,l())}function l(){const s=o.clientWidth,f=window.innerHeight-window.innerHeight/4;if(g=h.width,v=h.height,s>0&&f>0){if(g>s){const b=s/g;g*=b,v*=b}if(v>f){const b=f/v;g*=b,v*=b}g=Math.floor(g),v=Math.floor(v)}t(0,n.width=g,n),t(0,n.height=v,n),t(0,n.style.width=`${g}px`,n),t(0,n.style.height=`${v}px`,n),p()}return t(1,h=new Image),t(1,h.crossOrigin="anonymous",h),t(1,h.onload=l,h),t(1,h.src=I,h),window.addEventListener("resize",$,{passive:!0}),()=>{window.removeEventListener("resize",$)}});function p(){if(K=new a([B,B,B],te,Oe),!(g===0||v===0)){c.drawImage(h,0,0,h.width,h.height,0,0,g,v),i=c.getImageData(0,0,g,v),d=[...i.data];for(let $=0;$<i.data.length;$+=4)K.insert([d[$],d[$+1],d[$+2]]);z=[],M(),C()}}function C(){const $=R(w),l=i.data;for(let s=0;s<l.length;s+=4){const f=ne(d[s],d[s+1],d[s+2]),b=$[f];l[s]=b[0],l[s+1]=b[1],l[s+2]=b[2]}c.putImageData(i,0,0)}const Q=Ie(C,100);function M(){K.dfs($=>{const l=[];K.dfs(s=>{s.data!==null&&l.push(s.data[0],s.data[1],s.data[2])},$),z.push(l)}),z.sort(($,l)=>$.length>l.length?-1:l.length>$.length?1:0)}function R($){const l={};for(let s=0;s<$;s++){const f=z[s];let b=[],H=0,J=0,G=0;for(let D=0;D<f.length;D+=3){const ue=ne(f[D],f[D+1],f[D+2]);b.push(ue),H+=f[D],J+=f[D+1],G+=f[D+2]}const U=f.length/3;H/=U,J/=U,G/=U;const fe=[H,J,G];for(let D=0;D<b.length;D++)l[b[D]]=fe}return l}function oe($){w=$,t(2,w)}const ie=()=>{t(1,h.src=I,h),p()};function le($){I=$,t(3,I)}function ce($){Y[$?"unshift":"push"](()=>{n=$,t(0,n)})}return[n,h,w,I,p,Q,oe,ie,le,ce]}class ke extends se{constructor(e){super(),ae(this,e,Te,xe,re,{})}}function ye(u){let e;return{c(){e=A("Octree Color Quantization")},l(t){e=L(t,"Octree Color Quantization")},m(t,a){x(t,e,a)},d(t){t&&_(e)}}}function qe(u){let e,t,a,m,r;return e=new de({props:{timestamp:1652328e3,$$slots:{default:[ye]},$$scope:{ctx:u}}}),{c(){S(e.$$.fragment),t=V(),a=W("p"),m=A("A color matrioska.")},l(o){O(e.$$.fragment,o),t=F(o),a=N(o,"P",{});var n=P(a);m=L(n,"A color matrioska."),n.forEach(_)},m(o,n){T(e,o,n),x(o,t,n),x(o,a,n),E(a,m),r=!0},p(o,n){const c={};n&1&&(c.$$scope={dirty:n,ctx:o}),e.$set(c)},i(o){r||(k(e.$$.fragment,o),r=!0)},o(o){y(e.$$.fragment,o),r=!1},d(o){q(e,o),o&&_(t),o&&_(a)}}}function Me(u){let e;return{c(){e=A("Demo")},l(t){e=L(t,"Demo")},m(t,a){x(t,e,a)},d(t){t&&_(e)}}}function Ae(u){let e,t,a,m,r,o,n,c,g,v,h,w,I;return e=new _e({props:{id:"demo",$$slots:{default:[Me]},$$scope:{ctx:u}}}),w=new ke({}),{c(){S(e.$$.fragment),t=V(),a=W("p"),m=A(`To get an idea on how this work. Imagine an Octree as an xyz axes
			plot. We can insert a rgb color by using each individual channel as
			a position. The r channel is the x coordiante, g is y and b is z.`),r=V(),o=W("p"),n=A(`Then you have to pick the smallest possible sub cube that contains
			the amount of colors specified in the `),c=W("var"),g=A("quantization"),v=A(" function."),h=V(),S(w.$$.fragment)},l(i){O(e.$$.fragment,i),t=F(i),a=N(i,"P",{});var d=P(a);m=L(d,`To get an idea on how this work. Imagine an Octree as an xyz axes
			plot. We can insert a rgb color by using each individual channel as
			a position. The r channel is the x coordiante, g is y and b is z.`),d.forEach(_),r=F(i),o=N(i,"P",{});var z=P(o);n=L(z,`Then you have to pick the smallest possible sub cube that contains
			the amount of colors specified in the `),c=N(z,"VAR",{});var B=P(c);g=L(B,"quantization"),B.forEach(_),v=L(z," function."),z.forEach(_),h=F(i),O(w.$$.fragment,i)},m(i,d){T(e,i,d),x(i,t,d),x(i,a,d),E(a,m),x(i,r,d),x(i,o,d),E(o,n),E(o,c),E(c,g),E(o,v),x(i,h,d),T(w,i,d),I=!0},p(i,d){const z={};d&1&&(z.$$scope={dirty:d,ctx:i}),e.$set(z)},i(i){I||(k(e.$$.fragment,i),k(w.$$.fragment,i),I=!0)},o(i){y(e.$$.fragment,i),y(w.$$.fragment,i),I=!1},d(i){q(e,i),i&&_(t),i&&_(a),i&&_(r),i&&_(o),i&&_(h),q(w,i)}}}function Le(u){let e,t,a,m;return e=new ee({props:{$$slots:{default:[qe]},$$scope:{ctx:u}}}),a=new ee({props:{$$slots:{default:[Ae]},$$scope:{ctx:u}}}),{c(){S(e.$$.fragment),t=V(),S(a.$$.fragment)},l(r){O(e.$$.fragment,r),t=F(r),O(a.$$.fragment,r)},m(r,o){T(e,r,o),x(r,t,o),T(a,r,o),m=!0},p(r,o){const n={};o&1&&(n.$$scope={dirty:o,ctx:r}),e.$set(n);const c={};o&1&&(c.$$scope={dirty:o,ctx:r}),a.$set(c)},i(r){m||(k(e.$$.fragment,r),k(a.$$.fragment,r),m=!0)},o(r){y(e.$$.fragment,r),y(a.$$.fragment,r),m=!1},d(r){q(e,r),r&&_(t),q(a,r)}}}function Qe(u){let e,t,a,m,r,o;return e=new we({props:{title:"Octree Color Quantization",description:"Using an octree to color quantize an image",keywords:"Octree, Javascript, Image Processing, Quantization, Canvas2D"}}),a=new pe({props:{$$slots:{default:[Le]},$$scope:{ctx:u}}}),r=new ge({}),{c(){S(e.$$.fragment),t=V(),S(a.$$.fragment),m=V(),S(r.$$.fragment)},l(n){O(e.$$.fragment,n),t=F(n),O(a.$$.fragment,n),m=F(n),O(r.$$.fragment,n)},m(n,c){T(e,n,c),x(n,t,c),T(a,n,c),x(n,m,c),T(r,n,c),o=!0},p(n,[c]){const g={};c&1&&(g.$$scope={dirty:c,ctx:n}),a.$set(g)},i(n){o||(k(e.$$.fragment,n),k(a.$$.fragment,n),k(r.$$.fragment,n),o=!0)},o(n){y(e.$$.fragment,n),y(a.$$.fragment,n),y(r.$$.fragment,n),o=!1},d(n){q(e,n),n&&_(t),q(a,n),n&&_(m),q(r,n)}}}class Ke extends se{constructor(e){super(),ae(this,e,null,Qe,re,{})}}export{Ke as default};
